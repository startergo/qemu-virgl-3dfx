diff -Nru ../orig/qemu-9.2.0/accel/kvm/kvm-all.c ./accel/kvm/kvm-all.c
--- ../orig/qemu-9.2.0/accel/kvm/kvm-all.c
+++ ./accel/kvm/kvm-all.c
@@ -1666,6 +1666,42 @@
     return 0;
 }
 
+void kvm_update_guest_pa_range(uint64_t start_pa, uint64_t size, void *host_va, int readonly, int add)
+{
+    KVMState *s = kvm_state;
+    KVMMemoryListener *kml = &s->memory_listener;
+
+    MemoryRegion mr;
+    MemoryRegionSection section;
+    RAMBlock ram_block;
+
+    memset(&ram_block, 0, sizeof(RAMBlock));
+    ram_block.mr = &mr;
+    ram_block.used_length = REAL_HOST_PAGE_ALIGN(size);
+    ram_block.max_length = REAL_HOST_PAGE_ALIGN(size);
+    ram_block.fd = -1;
+    ram_block.page_size = getpagesize();
+    ram_block.host = host_va;
+    ram_block.flags |= RAM_PREALLOC;
+
+    memory_region_init(&mr, NULL, NULL, REAL_HOST_PAGE_ALIGN(size));
+    mr.ram = true;
+    mr.ram_block = &ram_block;
+    mr.readonly = readonly;
+    mr.nonvolatile = false;
+
+    section.mr = &mr;
+    section.fv = 0;
+    section.offset_within_region = 0;
+    section.size = mr.size;
+    section.offset_within_address_space = start_pa;
+    section.readonly = mr.readonly;
+    section.nonvolatile = mr.nonvolatile;
+
+    kvm_set_phys_mem(kml, &section, add);
+    object_unref(OBJECT(&mr));
+}
+
 static void kvm_region_add(MemoryListener *listener,
                            MemoryRegionSection *section)
 {
diff -Nru ../orig/qemu-9.2.0/audio/audio.c ./audio/audio.c
--- ../orig/qemu-9.2.0/audio/audio.c
+++ ./audio/audio.c
@@ -1407,12 +1407,18 @@
 #endif
 }
 
+void audio_generic_initialize_buffer_in(HWVoiceIn *hw)
+{
+    g_free(hw->buf_emul);
+    hw->size_emul = hw->samples * hw->info.bytes_per_frame;
+    hw->buf_emul = g_malloc(hw->size_emul);
+    hw->pos_emul = hw->pending_emul = 0;
+}
+
 void audio_generic_run_buffer_in(HWVoiceIn *hw)
 {
     if (unlikely(!hw->buf_emul)) {
-        hw->size_emul = hw->samples * hw->info.bytes_per_frame;
-        hw->buf_emul = g_malloc(hw->size_emul);
-        hw->pos_emul = hw->pending_emul = 0;
+        audio_generic_initialize_buffer_in(hw);
     }
 
     while (hw->pending_emul < hw->size_emul) {
@@ -1446,6 +1452,14 @@
     hw->pending_emul -= size;
 }
 
+void audio_generic_initialize_buffer_out(HWVoiceOut *hw)
+{
+    g_free(hw->buf_emul);
+    hw->size_emul = hw->samples * hw->info.bytes_per_frame;
+    hw->buf_emul = g_malloc(hw->size_emul);
+    hw->pos_emul = hw->pending_emul = 0;
+}
+
 size_t audio_generic_buffer_get_free(HWVoiceOut *hw)
 {
     if (hw->buf_emul) {
@@ -1477,9 +1491,7 @@
 void *audio_generic_get_buffer_out(HWVoiceOut *hw, size_t *size)
 {
     if (unlikely(!hw->buf_emul)) {
-        hw->size_emul = hw->samples * hw->info.bytes_per_frame;
-        hw->buf_emul = g_malloc(hw->size_emul);
-        hw->pos_emul = hw->pending_emul = 0;
+        audio_generic_initialize_buffer_out(hw);
     }
 
     *size = MIN(hw->size_emul - hw->pending_emul,
diff -Nru ../orig/qemu-9.2.0/audio/audio_int.h ./audio/audio_int.h
--- ../orig/qemu-9.2.0/audio/audio_int.h
+++ ./audio/audio_int.h
@@ -187,9 +187,11 @@
     void   (*volume_in)(HWVoiceIn *hw, Volume *vol);
 };
 
+void audio_generic_initialize_buffer_in(HWVoiceIn *hw);
 void audio_generic_run_buffer_in(HWVoiceIn *hw);
 void *audio_generic_get_buffer_in(HWVoiceIn *hw, size_t *size);
 void audio_generic_put_buffer_in(HWVoiceIn *hw, void *buf, size_t size);
+void audio_generic_initialize_buffer_out(HWVoiceOut *hw);
 void audio_generic_run_buffer_out(HWVoiceOut *hw);
 size_t audio_generic_buffer_get_free(HWVoiceOut *hw);
 void *audio_generic_get_buffer_out(HWVoiceOut *hw, size_t *size);
diff -Nru ../orig/qemu-9.2.0/audio/coreaudio.m ./audio/coreaudio.m
--- ../orig/qemu-9.2.0/audio/coreaudio.m
+++ ./audio/coreaudio.m
@@ -33,37 +33,37 @@
 #define AUDIO_CAP "coreaudio"
 #include "audio_int.h"
 
-typedef struct coreaudioVoiceOut {
+typedef struct CoreaudioVoiceOut {
     HWVoiceOut hw;
     pthread_mutex_t buf_mutex;
-    AudioDeviceID outputDeviceID;
-    int frameSizeSetting;
-    uint32_t bufferCount;
-    UInt32 audioDevicePropertyBufferFrameSize;
+    AudioDeviceID device_id;
+    int frame_size_setting;
+    uint32_t buffer_count;
+    UInt32 device_frame_size;
     AudioDeviceIOProcID ioprocid;
     bool enabled;
-} coreaudioVoiceOut;
+} CoreaudioVoiceOut;
 
-static const AudioObjectPropertyAddress voice_addr = {
+static const AudioObjectPropertyAddress voice_out_addr = {
     kAudioHardwarePropertyDefaultOutputDevice,
     kAudioObjectPropertyScopeGlobal,
     kAudioObjectPropertyElementMain
 };
 
-static OSStatus coreaudio_get_voice(AudioDeviceID *id)
+static OSStatus coreaudio_get_voice_out(AudioDeviceID *id)
 {
     UInt32 size = sizeof(*id);
 
     return AudioObjectGetPropertyData(kAudioObjectSystemObject,
-                                      &voice_addr,
+                                      &voice_out_addr,
                                       0,
                                       NULL,
                                       &size,
                                       id);
 }
 
-static OSStatus coreaudio_get_framesizerange(AudioDeviceID id,
-                                             AudioValueRange *framerange)
+static OSStatus coreaudio_get_out_framesizerange(AudioDeviceID id,
+                                                 AudioValueRange *framerange)
 {
     UInt32 size = sizeof(*framerange);
     AudioObjectPropertyAddress addr = {
@@ -80,7 +80,7 @@
                                       framerange);
 }
 
-static OSStatus coreaudio_get_framesize(AudioDeviceID id, UInt32 *framesize)
+static OSStatus coreaudio_get_out_framesize(AudioDeviceID id, UInt32 *framesize)
 {
     UInt32 size = sizeof(*framesize);
     AudioObjectPropertyAddress addr = {
@@ -97,7 +97,7 @@
                                       framesize);
 }
 
-static OSStatus coreaudio_set_framesize(AudioDeviceID id, UInt32 *framesize)
+static OSStatus coreaudio_set_out_framesize(AudioDeviceID id, UInt32 *framesize)
 {
     UInt32 size = sizeof(*framesize);
     AudioObjectPropertyAddress addr = {
@@ -114,8 +114,8 @@
                                       framesize);
 }
 
-static OSStatus coreaudio_set_streamformat(AudioDeviceID id,
-                                           AudioStreamBasicDescription *d)
+static OSStatus coreaudio_set_out_streamformat(AudioDeviceID id,
+                                               AudioStreamBasicDescription *d)
 {
     UInt32 size = sizeof(*d);
     AudioObjectPropertyAddress addr = {
@@ -132,7 +132,7 @@
                                       d);
 }
 
-static OSStatus coreaudio_get_isrunning(AudioDeviceID id, UInt32 *result)
+static OSStatus coreaudio_get_out_isrunning(AudioDeviceID id, UInt32 *result)
 {
     UInt32 size = sizeof(*result);
     AudioObjectPropertyAddress addr = {
@@ -149,7 +149,7 @@
                                       result);
 }
 
-static void coreaudio_logstatus (OSStatus status)
+static void coreaudio_logstatus(OSStatus status)
 {
     const char *str = "BUG";
 
@@ -199,14 +199,14 @@
         break;
 
     default:
-        AUD_log (AUDIO_CAP, "Reason: status code %" PRId32 "\n", (int32_t)status);
+        AUD_log(AUDIO_CAP, "Reason: status code %" PRId32 "\n", (int32_t)status);
         return;
     }
 
-    AUD_log (AUDIO_CAP, "Reason: %s\n", str);
+    AUD_log(AUDIO_CAP, "Reason: %s\n", str);
 }
 
-static void G_GNUC_PRINTF (2, 3) coreaudio_logerr (
+static void G_GNUC_PRINTF(2, 3) coreaudio_logerr(
     OSStatus status,
     const char *fmt,
     ...
@@ -214,14 +214,14 @@
 {
     va_list ap;
 
-    va_start (ap, fmt);
-    AUD_log (AUDIO_CAP, fmt, ap);
-    va_end (ap);
+    va_start(ap, fmt);
+    AUD_log(AUDIO_CAP, fmt, ap);
+    va_end(ap);
 
-    coreaudio_logstatus (status);
+    coreaudio_logstatus(status);
 }
 
-static void G_GNUC_PRINTF (3, 4) coreaudio_logerr2 (
+static void G_GNUC_PRINTF(3, 4) coreaudio_logerr2(
     OSStatus status,
     const char *typ,
     const char *fmt,
@@ -230,58 +230,60 @@
 {
     va_list ap;
 
-    AUD_log (AUDIO_CAP, "Could not initialize %s\n", typ);
+    AUD_log(AUDIO_CAP, "Could not initialize %s\n", typ);
 
-    va_start (ap, fmt);
-    AUD_vlog (AUDIO_CAP, fmt, ap);
-    va_end (ap);
+    va_start(ap, fmt);
+    AUD_vlog(AUDIO_CAP, fmt, ap);
+    va_end(ap);
 
-    coreaudio_logstatus (status);
+    coreaudio_logstatus(status);
 }
 
 #define coreaudio_playback_logerr(status, ...) \
     coreaudio_logerr2(status, "playback", __VA_ARGS__)
 
-static int coreaudio_buf_lock (coreaudioVoiceOut *core, const char *fn_name)
+static int coreaudio_voice_out_buf_lock(CoreaudioVoiceOut *core,
+                                        const char *fn_name)
 {
     int err;
 
-    err = pthread_mutex_lock (&core->buf_mutex);
+    err = pthread_mutex_lock(&core->buf_mutex);
     if (err) {
-        dolog ("Could not lock voice for %s\nReason: %s\n",
-               fn_name, strerror (err));
+        dolog("Could not lock voice for %s\nReason: %s\n",
+              fn_name, strerror(err));
         return -1;
     }
     return 0;
 }
 
-static int coreaudio_buf_unlock (coreaudioVoiceOut *core, const char *fn_name)
+static int coreaudio_voice_out_buf_unlock(CoreaudioVoiceOut *core,
+                                          const char *fn_name)
 {
     int err;
 
-    err = pthread_mutex_unlock (&core->buf_mutex);
+    err = pthread_mutex_unlock(&core->buf_mutex);
     if (err) {
-        dolog ("Could not unlock voice for %s\nReason: %s\n",
-               fn_name, strerror (err));
+        dolog("Could not unlock voice for %s\nReason: %s\n",
+               fn_name, strerror(err));
         return -1;
     }
     return 0;
 }
 
-#define COREAUDIO_WRAPPER_FUNC(name, ret_type, args_decl, args) \
-    static ret_type glue(coreaudio_, name)args_decl             \
-    {                                                           \
-        coreaudioVoiceOut *core = (coreaudioVoiceOut *) hw;     \
-        ret_type ret;                                           \
-                                                                \
-        if (coreaudio_buf_lock(core, "coreaudio_" #name)) {         \
-            return 0;                                           \
-        }                                                       \
-                                                                \
-        ret = glue(audio_generic_, name)args;                   \
-                                                                \
-        coreaudio_buf_unlock(core, "coreaudio_" #name);             \
-        return ret;                                             \
+#define COREAUDIO_WRAPPER_FUNC(name, ret_type, args_decl, args)       \
+    static ret_type glue(coreaudio_, name)args_decl                   \
+    {                                                                 \
+        CoreaudioVoiceOut *core = (CoreaudioVoiceOut *)hw;            \
+        ret_type ret;                                                 \
+                                                                      \
+        if (coreaudio_voice_out_buf_lock(core, "coreaudio_" #name)) { \
+            return 0;                                                 \
+        }                                                             \
+                                                                      \
+        ret = glue(audio_generic_, name)args;                         \
+                                                                      \
+        coreaudio_voice_out_buf_unlock(core, "coreaudio_" #name);     \
+        return ret;                                                   \
     }
 COREAUDIO_WRAPPER_FUNC(buffer_get_free, size_t, (HWVoiceOut *hw), (hw))
 COREAUDIO_WRAPPER_FUNC(get_buffer_out, void *, (HWVoiceOut *hw, size_t *size),
@@ -297,7 +299,7 @@
  * callback to feed audiooutput buffer. called without BQL.
  * allowed to lock "buf_mutex", but disallowed to have any other locks.
  */
-static OSStatus audioDeviceIOProc(
+static OSStatus out_device_ioproc(
     AudioDeviceID inDevice,
     const AudioTimeStamp *inNow,
     const AudioBufferList *inInputData,
@@ -306,33 +308,33 @@
     const AudioTimeStamp *inOutputTime,
     void *hwptr)
 {
-    UInt32 frameCount, pending_frames;
+    UInt32 frame_size, pending_frames;
     void *out = outOutputData->mBuffers[0].mData;
     HWVoiceOut *hw = hwptr;
-    coreaudioVoiceOut *core = (coreaudioVoiceOut *) hwptr;
+    CoreaudioVoiceOut *core = hwptr;
     size_t len;
 
-    if (coreaudio_buf_lock (core, "audioDeviceIOProc")) {
+    if (coreaudio_voice_out_buf_lock(core, "out_device_ioproc")) {
         inInputTime = 0;
         return 0;
     }
 
-    if (inDevice != core->outputDeviceID) {
-        coreaudio_buf_unlock (core, "audioDeviceIOProc(old device)");
+    if (inDevice != core->device_id) {
+        coreaudio_voice_out_buf_unlock(core, "out_device_ioproc(old device)");
         return 0;
     }
 
-    frameCount = core->audioDevicePropertyBufferFrameSize;
+    frame_size = core->device_frame_size;
     pending_frames = hw->pending_emul / hw->info.bytes_per_frame;
 
     /* if there are not enough samples, set signal and return */
-    if (pending_frames < frameCount) {
+    if (pending_frames < frame_size) {
         inInputTime = 0;
-        coreaudio_buf_unlock (core, "audioDeviceIOProc(empty)");
+        coreaudio_voice_out_buf_unlock(core, "out_device_ioproc(empty)");
         return 0;
     }
 
-    len = frameCount * hw->info.bytes_per_frame;
+    len = frame_size * hw->info.bytes_per_frame;
     while (len) {
         size_t write_len, start;
 
@@ -348,16 +350,19 @@
         out += write_len;
     }
 
-    coreaudio_buf_unlock (core, "audioDeviceIOProc");
+    coreaudio_voice_out_buf_unlock(core, "out_device_ioproc");
     return 0;
 }
 
-static OSStatus init_out_device(coreaudioVoiceOut *core)
+static OSStatus init_out_device(CoreaudioVoiceOut *core)
 {
     OSStatus status;
-    AudioValueRange frameRange;
+    AudioDeviceID device_id;
+    AudioValueRange framerange;
+    UInt32 device_frame_size;
+    AudioDeviceIOProcID ioprocid;
 
-    AudioStreamBasicDescription streamBasicDescription = {
+    AudioStreamBasicDescription stream_basic_description = {
         .mBitsPerChannel = core->hw.info.bits,
         .mBytesPerFrame = core->hw.info.bytes_per_frame,
         .mBytesPerPacket = core->hw.info.bytes_per_frame,
@@ -368,76 +373,71 @@
         .mSampleRate = core->hw.info.freq
     };
 
-    status = coreaudio_get_voice(&core->outputDeviceID);
+    status = coreaudio_get_voice_out(&device_id);
     if (status != kAudioHardwareNoError) {
-        coreaudio_playback_logerr (status,
-                                   "Could not get default output Device\n");
+        coreaudio_playback_logerr(status,
+                                  "Could not get default output Device\n");
         return status;
     }
-    if (core->outputDeviceID == kAudioDeviceUnknown) {
-        dolog ("Could not initialize playback - Unknown Audiodevice\n");
+    if (device_id == kAudioDeviceUnknown) {
+        dolog("Could not initialize playback - Unknown Audiodevice\n");
         return status;
     }
 
     /* get minimum and maximum buffer frame sizes */
-    status = coreaudio_get_framesizerange(core->outputDeviceID,
-                                          &frameRange);
+    status = coreaudio_get_out_framesizerange(device_id, &framerange);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
     if (status != kAudioHardwareNoError) {
-        coreaudio_playback_logerr (status,
-                                    "Could not get device buffer frame range\n");
+        coreaudio_playback_logerr(status,
+                                  "Could not get device buffer frame range\n");
         return status;
     }
 
-    if (frameRange.mMinimum > core->frameSizeSetting) {
-        core->audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMinimum;
-        dolog ("warning: Upsizing Buffer Frames to %f\n", frameRange.mMinimum);
-    } else if (frameRange.mMaximum < core->frameSizeSetting) {
-        core->audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMaximum;
-        dolog ("warning: Downsizing Buffer Frames to %f\n", frameRange.mMaximum);
+    if (framerange.mMinimum > core->frame_size_setting) {
+        device_frame_size = framerange.mMinimum;
+        dolog("warning: Upsizing Buffer Frames to %f\n", framerange.mMinimum);
+    } else if (framerange.mMaximum < core->frame_size_setting) {
+        device_frame_size = framerange.mMaximum;
+        dolog("warning: Downsizing Buffer Frames to %f\n", framerange.mMaximum);
     } else {
-        core->audioDevicePropertyBufferFrameSize = core->frameSizeSetting;
+        device_frame_size = core->frame_size_setting;
     }
 
     /* set Buffer Frame Size */
-    status = coreaudio_set_framesize(core->outputDeviceID,
-                                     &core->audioDevicePropertyBufferFrameSize);
+    status = coreaudio_set_out_framesize(device_id, &device_frame_size);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
     if (status != kAudioHardwareNoError) {
-        coreaudio_playback_logerr (status,
-                                    "Could not set device buffer frame size %" PRIu32 "\n",
-                                    (uint32_t)core->audioDevicePropertyBufferFrameSize);
+        coreaudio_playback_logerr(status,
+                                  "Could not set device buffer frame size %" PRIu32 "\n",
+                                  (uint32_t)device_frame_size);
         return status;
     }
 
     /* get Buffer Frame Size */
-    status = coreaudio_get_framesize(core->outputDeviceID,
-                                     &core->audioDevicePropertyBufferFrameSize);
+    status = coreaudio_get_out_framesize(device_id, &device_frame_size);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
     if (status != kAudioHardwareNoError) {
-        coreaudio_playback_logerr (status,
-                                    "Could not get device buffer frame size\n");
+        coreaudio_playback_logerr(status,
+                                  "Could not get device buffer frame size\n");
         return status;
     }
-    core->hw.samples = core->bufferCount * core->audioDevicePropertyBufferFrameSize;
 
     /* set Samplerate */
-    status = coreaudio_set_streamformat(core->outputDeviceID,
-                                        &streamBasicDescription);
+    status = coreaudio_set_out_streamformat(device_id,
+                                            &stream_basic_description);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
     if (status != kAudioHardwareNoError) {
-        coreaudio_playback_logerr (status,
-                                   "Could not set samplerate %lf\n",
-                                   streamBasicDescription.mSampleRate);
-        core->outputDeviceID = kAudioDeviceUnknown;
+        coreaudio_playback_logerr(status,
+                                  "Could not set samplerate %lf\n",
+                                  stream_basic_description.mSampleRate);
         return status;
     }
 
@@ -451,30 +451,35 @@
      * Therefore, the specified callback must be designed to avoid a deadlock
      * with the callers of AudioObjectGetPropertyData.
      */
-    core->ioprocid = NULL;
-    status = AudioDeviceCreateIOProcID(core->outputDeviceID,
-                                       audioDeviceIOProc,
+    ioprocid = NULL;
+    status = AudioDeviceCreateIOProcID(device_id,
+                                       out_device_ioproc,
                                        &core->hw,
-                                       &core->ioprocid);
+                                       &ioprocid);
     if (status == kAudioHardwareBadDeviceError) {
         return 0;
     }
-    if (status != kAudioHardwareNoError || core->ioprocid == NULL) {
-        coreaudio_playback_logerr (status, "Could not set IOProc\n");
-        core->outputDeviceID = kAudioDeviceUnknown;
+    if (status != kAudioHardwareNoError || ioprocid == NULL) {
+        coreaudio_playback_logerr(status, "Could not set IOProc\n");
         return status;
     }
 
+    core->device_id = device_id;
+    core->device_frame_size = device_frame_size;
+    core->hw.samples = core->buffer_count * core->device_frame_size;
+    audio_generic_initialize_buffer_out(&core->hw);
+    core->ioprocid = ioprocid;
+
     return 0;
 }
 
-static void fini_out_device(coreaudioVoiceOut *core)
+static void fini_out_device(CoreaudioVoiceOut *core)
 {
     OSStatus status;
     UInt32 isrunning;
 
     /* stop playback */
-    status = coreaudio_get_isrunning(core->outputDeviceID, &isrunning);
+    status = coreaudio_get_out_isrunning(core->device_id, &isrunning);
     if (status != kAudioHardwareBadObjectError) {
         if (status != kAudioHardwareNoError) {
             coreaudio_logerr(status,
@@ -482,7 +487,7 @@
         }
 
         if (isrunning) {
-            status = AudioDeviceStop(core->outputDeviceID, core->ioprocid);
+            status = AudioDeviceStop(core->device_id, core->ioprocid);
             if (status != kAudioHardwareBadDeviceError && status != kAudioHardwareNoError) {
                 coreaudio_logerr(status, "Could not stop playback\n");
             }
@@ -490,20 +495,20 @@
     }
 
     /* remove callback */
-    status = AudioDeviceDestroyIOProcID(core->outputDeviceID,
+    status = AudioDeviceDestroyIOProcID(core->device_id,
                                         core->ioprocid);
     if (status != kAudioHardwareBadDeviceError && status != kAudioHardwareNoError) {
         coreaudio_logerr(status, "Could not remove IOProc\n");
     }
-    core->outputDeviceID = kAudioDeviceUnknown;
+    core->device_id = kAudioDeviceUnknown;
 }
 
-static void update_device_playback_state(coreaudioVoiceOut *core)
+static void update_out_device_playback_state(CoreaudioVoiceOut *core)
 {
     OSStatus status;
     UInt32 isrunning;
 
-    status = coreaudio_get_isrunning(core->outputDeviceID, &isrunning);
+    status = coreaudio_get_out_isrunning(core->device_id, &isrunning);
     if (status != kAudioHardwareNoError) {
         if (status != kAudioHardwareBadObjectError) {
             coreaudio_logerr(status,
@@ -516,15 +521,15 @@
     if (core->enabled) {
         /* start playback */
         if (!isrunning) {
-            status = AudioDeviceStart(core->outputDeviceID, core->ioprocid);
+            status = AudioDeviceStart(core->device_id, core->ioprocid);
             if (status != kAudioHardwareBadDeviceError && status != kAudioHardwareNoError) {
-                coreaudio_logerr (status, "Could not resume playback\n");
+                coreaudio_logerr(status, "Could not resume playback\n");
             }
         }
     } else {
         /* stop playback */
         if (isrunning) {
-            status = AudioDeviceStop(core->outputDeviceID,
+            status = AudioDeviceStop(core->device_id,
                                      core->ioprocid);
             if (status != kAudioHardwareBadDeviceError && status != kAudioHardwareNoError) {
                 coreaudio_logerr(status, "Could not pause playback\n");
@@ -534,22 +539,24 @@
 }
 
 /* called without BQL. */
-static OSStatus handle_voice_change(
+static OSStatus handle_voice_out_change(
     AudioObjectID in_object_id,
     UInt32 in_number_addresses,
     const AudioObjectPropertyAddress *in_addresses,
     void *in_client_data)
 {
-    coreaudioVoiceOut *core = in_client_data;
+    CoreaudioVoiceOut *core = in_client_data;
 
     bql_lock();
 
-    if (core->outputDeviceID) {
+    if (core->device_id) {
         fini_out_device(core);
     }
 
-    if (!init_out_device(core)) {
-        update_device_playback_state(core);
+    init_out_device(core);
+
+    if (core->device_id) {
+        update_out_device_playback_state(core);
     }
 
     bql_unlock();
@@ -560,7 +567,7 @@
                               void *drv_opaque)
 {
     OSStatus status;
-    coreaudioVoiceOut *core = (coreaudioVoiceOut *) hw;
+    CoreaudioVoiceOut *core = (CoreaudioVoiceOut *)hw;
     int err;
     Audiodev *dev = drv_opaque;
     AudiodevCoreaudioPerDirectionOptions *cpdo = dev->u.coreaudio.out;
@@ -569,33 +576,34 @@
     /* create mutex */
     err = pthread_mutex_init(&core->buf_mutex, NULL);
     if (err) {
-        dolog("Could not create mutex\nReason: %s\n", strerror (err));
+        dolog("Could not create mutex\nReason: %s\n", strerror(err));
         return -1;
     }
 
     obt_as = *as;
     as = &obt_as;
     as->fmt = AUDIO_FORMAT_F32;
-    audio_pcm_init_info (&hw->info, as);
+    audio_pcm_init_info(&hw->info, as);
 
-    core->frameSizeSetting = audio_buffer_frames(
+    core->frame_size_setting = audio_buffer_frames(
         qapi_AudiodevCoreaudioPerDirectionOptions_base(cpdo), as, 11610);
 
-    core->bufferCount = cpdo->has_buffer_count ? cpdo->buffer_count : 4;
+    core->buffer_count = cpdo->has_buffer_count ? cpdo->buffer_count : 4;
 
     status = AudioObjectAddPropertyListener(kAudioObjectSystemObject,
-                                            &voice_addr, handle_voice_change,
+                                            &voice_out_addr,
+                                            handle_voice_out_change,
                                             core);
     if (status != kAudioHardwareNoError) {
-        coreaudio_playback_logerr (status,
-                                   "Could not listen to voice property change\n");
+        coreaudio_playback_logerr(status,
+                                  "Could not listen to voice property change\n");
         return -1;
     }
 
     if (init_out_device(core)) {
         status = AudioObjectRemovePropertyListener(kAudioObjectSystemObject,
-                                                   &voice_addr,
-                                                   handle_voice_change,
+                                                   &voice_out_addr,
+                                                   handle_voice_out_change,
                                                    core);
         if (status != kAudioHardwareNoError) {
             coreaudio_playback_logerr(status,
@@ -612,11 +620,11 @@
 {
     OSStatus status;
     int err;
-    coreaudioVoiceOut *core = (coreaudioVoiceOut *) hw;
+    CoreaudioVoiceOut *core = (CoreaudioVoiceOut *)hw;
 
     status = AudioObjectRemovePropertyListener(kAudioObjectSystemObject,
-                                               &voice_addr,
-                                               handle_voice_change,
+                                               &voice_out_addr,
+                                               handle_voice_out_change,
                                                core);
     if (status != kAudioHardwareNoError) {
         coreaudio_logerr(status, "Could not remove voice property change listener\n");
@@ -627,16 +635,16 @@
     /* destroy mutex */
     err = pthread_mutex_destroy(&core->buf_mutex);
     if (err) {
-        dolog("Could not destroy mutex\nReason: %s\n", strerror (err));
+        dolog("Could not destroy mutex\nReason: %s\n", strerror(err));
     }
 }
 
 static void coreaudio_enable_out(HWVoiceOut *hw, bool enable)
 {
-    coreaudioVoiceOut *core = (coreaudioVoiceOut *) hw;
+    CoreaudioVoiceOut *core = (CoreaudioVoiceOut *)hw;
 
     core->enabled = enable;
-    update_device_playback_state(core);
+    update_out_device_playback_state(core);
 }
 
 static void *coreaudio_audio_init(Audiodev *dev, Error **errp)
@@ -644,7 +652,7 @@
     return dev;
 }
 
-static void coreaudio_audio_fini (void *opaque)
+static void coreaudio_audio_fini(void *opaque)
 {
 }
 
@@ -670,7 +678,7 @@
     .pcm_ops        = &coreaudio_pcm_ops,
     .max_voices_out = 1,
     .max_voices_in  = 0,
-    .voice_size_out = sizeof (coreaudioVoiceOut),
+    .voice_size_out = sizeof(CoreaudioVoiceOut),
     .voice_size_in  = 0
 };
 
 diff -Nru ../orig/qemu-9.2.0/block/nfs.c ./block/nfs.c
--- ../orig/qemu-9.2.0/block/nfs.c
+++ ./block/nfs.c
@@ -47,7 +47,6 @@
 #include "qapi/qobject-output-visitor.h"
 #include <nfsc/libnfs.h>
 
-
 #define QEMU_NFS_MAX_READAHEAD_SIZE 1048576
 #define QEMU_NFS_MAX_PAGECACHE_SIZE (8388608 / NFS_BLKSIZE)
 #define QEMU_NFS_MAX_DEBUG_LEVEL 2
@@ -74,8 +73,11 @@
     struct stat *st;
     Coroutine *co;
     NFSClient *client;
+    void *buf;
 } NFSRPC;
 
+static void nfs_set_events(NFSClient *client);
+
 static int nfs_parse_uri(const char *filename, QDict *options, Error **errp)
 {
     g_autoptr(GUri) uri = g_uri_parse(filename, G_URI_FLAGS_NONE, NULL);
@@ -268,8 +270,19 @@
     NFSRPC task;
 
     nfs_co_init_task(bs, &task);
-    task.iov = iov;
+#ifdef LIBNFS_API_V2
+    WITH_QEMU_LOCK_GUARD(&client->mutex) {
+        if (nfs_pread_async(client->context, client->fh,
+                            iov->iov[0].iov_base,
+                            bytes > iov->iov[0].iov_len ? iov->iov[0].iov_len : bytes,
+                            offset, nfs_co_generic_cb, &task) != 0) {
+            return -ENOMEM;
+        }
 
+        nfs_set_events(client);
+    }
+#else
+    task.iov = iov;
     WITH_QEMU_LOCK_GUARD(&client->mutex) {
         if (nfs_pread_async(client->context, client->fh,
                             offset, bytes, nfs_co_generic_cb, &task) != 0) {
@@ -278,6 +291,7 @@
 
         nfs_set_events(client);
     }
+#endif
     while (!task.complete) {
         qemu_coroutine_yield();
     }
@@ -300,26 +314,30 @@
 {
     NFSClient *client = bs->opaque;
     NFSRPC task;
-    char *buf = NULL;
+    void *buf = NULL;
     bool my_buffer = false;
 
     nfs_co_init_task(bs, &task);
+    task.buf = buf;
 
-    if (iov->niov != 1) {
-        buf = g_try_malloc(bytes);
-        if (bytes && buf == NULL) {
-            return -ENOMEM;
-        }
-        qemu_iovec_to_buf(iov, 0, buf, bytes);
-        my_buffer = true;
-    } else {
+    if (iov->niov == 1) {
         buf = iov->iov[0].iov_base;
+    } else {
+        buf = g_malloc0(bytes);
+        my_buffer = true;
+        qemu_iovec_to_buf(iov, 0, buf, bytes);
     }
 
     WITH_QEMU_LOCK_GUARD(&client->mutex) {
+#ifdef LIBNFS_API_V2
+        if (nfs_pwrite_async(client->context, client->fh,
+                             buf, bytes, offset,
+                             nfs_co_generic_cb, &task) != 0) {
+#else
         if (nfs_pwrite_async(client->context, client->fh,
                              offset, bytes, buf,
                              nfs_co_generic_cb, &task) != 0) {
+#endif
             if (my_buffer) {
                 g_free(buf);
             }
@@ -332,12 +350,15 @@
         qemu_coroutine_yield();
     }
 
-    if (my_buffer) {
-        g_free(buf);
+    if (task.ret < 0) {
+        if (my_buffer) {
+            g_free(buf);
+        }
+        return task.ret;
     }
 
-    if (task.ret != bytes) {
-        return task.ret < 0 ? task.ret : -EIO;
+    if (my_buffer) {
+        g_free(buf);
     }
 
     return 0;
diff -Nru ../orig/qemu-9.2.0/hw/display/virtio-gpu-virgl.c ./hw/display/virtio-gpu-virgl.c
--- ../orig/qemu-9.2.0/hw/display/virtio-gpu-virgl.c
+++ ./hw/display/virtio-gpu-virgl.c
@@ -396,11 +396,42 @@
     }
 }
 
+static DisplayGLTexture virgl_borrow_texture_for_scanout(uint32_t id)
+{
+    DisplayGLTexture texture = {};
+    struct virgl_renderer_resource_info info;
+    int ret;
+
+#if VIRGL_VERSION_MAJOR >= 1
+    struct virgl_renderer_resource_info_ext ext;
+    memset(&ext, 0, sizeof(ext));
+#ifdef HAVE_VIRGL_RENDERER_BORROW_TEXTURE_FOR_SCANOUT
+    ret = virgl_renderer_borrow_texture_for_scanout(id, &ext);
+#else
+    ret = virgl_renderer_resource_get_info_ext(id, &ext);
+#endif
+    info = ext.base;
+    texture.d3d_tex2d = ext.d3d_tex2d;
+#else
+    memset(&info, 0, sizeof(info));
+    ret = virgl_renderer_resource_get_info(id, &info);
+#endif
+    if (ret) {
+        return texture;
+    }
+
+    texture.y_0_top = info.flags & VIRTIO_GPU_RESOURCE_FLAG_Y_0_TOP;
+    texture.width = info.width;
+    texture.height = info.height;
+    texture.id = info.tex_id;
+
+    return texture;
+}
+
 static void virgl_cmd_set_scanout(VirtIOGPU *g,
                                   struct virtio_gpu_ctrl_command *cmd)
 {
     struct virtio_gpu_set_scanout ss;
-    int ret;
 
     VIRTIO_GPU_FILL_CMD(ss);
     trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,
@@ -415,35 +446,13 @@
     g->parent_obj.enable = 1;
 
     if (ss.resource_id && ss.r.width && ss.r.height) {
-        struct virgl_renderer_resource_info info;
-        void *d3d_tex2d = NULL;
-
-#if VIRGL_VERSION_MAJOR >= 1
-        struct virgl_renderer_resource_info_ext ext;
-        memset(&ext, 0, sizeof(ext));
-        ret = virgl_renderer_resource_get_info_ext(ss.resource_id, &ext);
-        info = ext.base;
-        d3d_tex2d = ext.d3d_tex2d;
-#else
-        memset(&info, 0, sizeof(info));
-        ret = virgl_renderer_resource_get_info(ss.resource_id, &info);
-#endif
-        if (ret) {
-            qemu_log_mask(LOG_GUEST_ERROR,
-                          "%s: illegal resource specified %d\n",
-                          __func__, ss.resource_id);
-            cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
-            return;
-        }
         qemu_console_resize(g->parent_obj.scanout[ss.scanout_id].con,
                             ss.r.width, ss.r.height);
         virgl_renderer_force_ctx_0();
         dpy_gl_scanout_texture(
-            g->parent_obj.scanout[ss.scanout_id].con, info.tex_id,
-            info.flags & VIRTIO_GPU_RESOURCE_FLAG_Y_0_TOP,
-            info.width, info.height,
-            ss.r.x, ss.r.y, ss.r.width, ss.r.height,
-            d3d_tex2d);
+            g->parent_obj.scanout[ss.scanout_id].con, ss.resource_id,
+            virgl_borrow_texture_for_scanout,
+            ss.r.x, ss.r.y, ss.r.width, ss.r.height);
     } else {
         dpy_gfx_replace_surface(
             g->parent_obj.scanout[ss.scanout_id].con, NULL);
diff -Nru ../orig/qemu-9.2.0/hw/i386/pc.c ./hw/i386/pc.c
--- ../orig/qemu-9.2.0/hw/i386/pc.c
+++ ./hw/i386/pc.c
@@ -1236,6 +1236,28 @@
     /* Super I/O */
     pc_superio_init(isa_bus, create_fdctrl, pcms->i8042_enabled,
                     pcms->vmport != ON_OFF_AUTO_ON, &error_fatal);
+    /* Glide pass-through */
+    glidept_mm_init();
+    /* MESA pass-through */
+    mesapt_mm_init();
+}
+
+void glidept_mm_init(void)
+{
+    DeviceState *glidept_dev = NULL;
+
+    glidept_dev = qdev_new(TYPE_GLIDEPT);
+    sysbus_realize(SYS_BUS_DEVICE(glidept_dev), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(glidept_dev), 0, GLIDEPT_MM_BASE);
+}
+
+void mesapt_mm_init(void)
+{
+    DeviceState *mesapt_dev = NULL;
+
+    mesapt_dev = qdev_new(TYPE_MESAPT);
+    sysbus_realize(SYS_BUS_DEVICE(mesapt_dev), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(mesapt_dev), 0, MESAPT_MM_BASE);
 }
 
 void pc_nic_init(PCMachineClass *pcmc, ISABus *isa_bus, PCIBus *pci_bus)
diff -Nru ../orig/qemu-9.2.0/include/hw/i386/pc.h ./include/hw/i386/pc.h
--- ../orig/qemu-9.2.0/include/hw/i386/pc.h
+++ ./include/hw/i386/pc.h
@@ -204,6 +204,25 @@
 
 #define TYPE_PORT92 "port92"
 
+#if (((QEMU_VERSION_MAJOR << 12) | (QEMU_VERSION_MINOR << 8) \
+     | QEMU_VERSION_MICRO) < 0x5100)
+#define qdev_new(x)         qdev_create(NULL,x)
+#define sysbus_realize(x,y) qdev_init_nofail((DeviceState *)x)
+#endif
+#if (((QEMU_VERSION_MAJOR << 12) | (QEMU_VERSION_MINOR << 8) \
+     | QEMU_VERSION_MICRO) < 0x9132)
+#define device_class_set_legacy_reset(x,y) x->reset = y
+#endif
+/* GLIDE pass-through */
+#define TYPE_GLIDEPT "glidept"
+#define GLIDEPT_MM_BASE 0xfbdff000
+void glidept_mm_init(void);
+
+/* MESA pass-through */
+#define TYPE_MESAPT "mesapt"
+#define MESAPT_MM_BASE 0xefffe000
+void mesapt_mm_init(void);
+
 /* pc_sysfw.c */
 void pc_system_flash_create(PCMachineState *pcms);
 void pc_system_flash_cleanup_unused(PCMachineState *pcms);
diff -Nru ../orig/qemu-9.2.0/include/sysemu/kvm.h ./include/sysemu/kvm.h
--- ../orig/qemu-9.2.0/include/sysemu/kvm.h
+++ ./include/sysemu/kvm.h
@@ -470,6 +470,8 @@
 
 #endif /* COMPILING_PER_TARGET */
 
+void kvm_update_guest_pa_range(uint64_t start_pa, uint64_t size, void *host_va, int readonly, int add);
+
 void kvm_cpu_synchronize_state(CPUState *cpu);
 
 void kvm_init_cpu_signals(CPUState *cpu);
diff -Nru ../orig/qemu-9.2.0/include/sysemu/whpx.h ./include/sysemu/whpx.h
--- ../orig/qemu-9.2.0/include/sysemu/whpx.h
+++ ./include/sysemu/whpx.h
@@ -19,6 +19,8 @@
 
 #ifdef CONFIG_WHPX
 
+void whpx_update_guest_pa_range(uint64_t start_pa, uint64_t size, void *host_va, int readonly, int add);
+
 int whpx_enabled(void);
 bool whpx_apic_in_platform(void);
 
diff -Nru ../orig/qemu-9.2.0/include/ui/console.h ./include/ui/console.h
--- ../orig/qemu-9.2.0/include/ui/console.h
+++ ./include/ui/console.h
@@ -131,16 +131,23 @@
     ObjectClass parent_class;
 };
 
+typedef struct DisplayGLTexture {
+    uint32_t id;
+    bool y_0_top;
+    uint32_t width;
+    uint32_t height;
+    void *d3d_tex2d;
+} DisplayGLTexture;
+
+typedef DisplayGLTexture (* DisplayGLTextureBorrower)(uint32_t id);
+
 typedef struct ScanoutTexture {
     uint32_t backing_id;
-    bool backing_y_0_top;
-    uint32_t backing_width;
-    uint32_t backing_height;
+    DisplayGLTextureBorrower backing_borrow;
     uint32_t x;
     uint32_t y;
     uint32_t width;
     uint32_t height;
-    void *d3d_tex2d;
 } ScanoutTexture;
 
 typedef struct QemuUIInfo {
@@ -153,6 +160,8 @@
     uint32_t  width;
     uint32_t  height;
     uint32_t  refresh_rate;
+    /* passthrough */
+    bool passthrough;
 } QemuUIInfo;
 
 /* cursor data format is 32bit RGBA */
@@ -240,12 +249,9 @@
     /* required if GL */
     void (*dpy_gl_scanout_texture)(DisplayChangeListener *dcl,
                                    uint32_t backing_id,
-                                   bool backing_y_0_top,
-                                   uint32_t backing_width,
-                                   uint32_t backing_height,
+                                   DisplayGLTextureBorrower backing_borrow,
                                    uint32_t x, uint32_t y,
-                                   uint32_t w, uint32_t h,
-                                   void *d3d_tex2d);
+                                   uint32_t w, uint32_t h);
     /* optional (default to true if has dpy_gl_scanout_dmabuf) */
     bool (*dpy_has_dmabuf)(DisplayChangeListener *dcl);
     /* optional */
@@ -325,11 +331,9 @@
                           pixman_format_code_t format);
 
 void dpy_gl_scanout_disable(QemuConsole *con);
-void dpy_gl_scanout_texture(QemuConsole *con,
-                            uint32_t backing_id, bool backing_y_0_top,
-                            uint32_t backing_width, uint32_t backing_height,
-                            uint32_t x, uint32_t y, uint32_t w, uint32_t h,
-                            void *d3d_tex2d);
+void dpy_gl_scanout_texture(QemuConsole *con, uint32_t backing_id,
+                            DisplayGLTextureBorrower backing_borrow,
+                            uint32_t x, uint32_t y, uint32_t w, uint32_t h);
 void dpy_gl_scanout_dmabuf(QemuConsole *con,
                            QemuDmaBuf *dmabuf);
 void dpy_gl_cursor_dmabuf(QemuConsole *con, QemuDmaBuf *dmabuf,
@@ -381,6 +385,7 @@
                                void *opaque);
 void graphic_console_close(QemuConsole *con);
 
+void graphic_hw_passthrough(QemuConsole *con, bool passthrough);
 void graphic_hw_update(QemuConsole *con);
 void graphic_hw_update_done(QemuConsole *con);
 void graphic_hw_invalidate(QemuConsole *con);
@@ -474,5 +479,20 @@
                                       char *device_address,
                                       size_t size,
                                       Error **errp);
+
+/* glidewnd.c */
+void glide_prepare_window(uint32_t, int, void *, void *);
+void glide_release_window(void *, void *);
+int glide_window_stat(const int);
+int glide_gui_fullscreen(int *, int *);
+void glide_renderer_stat(const int);
+
+/* mglcntx.c */
+void mesa_renderer_stat(const int);
+void mesa_prepare_window(int, int, int, void *);
+void mesa_release_window(void);
+void mesa_cursor_define(int, int, int, int, const void *);
+void mesa_mouse_warp(int, int, const int);
+int mesa_gui_fullscreen(int *);
 
 #endif
diff -Nru ../orig/qemu-9.2.0/include/ui/egl-helpers.h ./include/ui/egl-helpers.h
--- ../orig/qemu-9.2.0/include/ui/egl-helpers.h
+++ ./include/ui/egl-helpers.h
@@ -56,7 +56,9 @@
 
 #endif
 
-EGLSurface qemu_egl_init_surface_x11(EGLContext ectx, EGLNativeWindowType win);
+EGLSurface qemu_egl_init_surface(EGLContext ectx, EGLNativeWindowType win);
+
+int qemu_egl_init_dpy_cocoa(DisplayGLMode mode);
 
 #if defined(CONFIG_X11) || defined(CONFIG_GBM)
 
diff -Nru ../orig/qemu-9.2.0/include/ui/gtk.h ./include/ui/gtk.h
--- ../orig/qemu-9.2.0/include/ui/gtk.h
+++ ./include/ui/gtk.h
@@ -21,7 +21,7 @@
 #include "ui/clipboard.h"
 #include "ui/console.h"
 #include "ui/kbd-state.h"
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 #include "ui/egl-helpers.h"
 #include "ui/egl-context.h"
 #endif
@@ -43,7 +43,7 @@
     cairo_surface_t *surface;
     double scale_x;
     double scale_y;
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     QemuGLShader *gls;
     EGLContext ectx;
     EGLSurface esurface;
@@ -171,12 +171,9 @@
 void gd_egl_scanout_disable(DisplayChangeListener *dcl);
 void gd_egl_scanout_texture(DisplayChangeListener *dcl,
                             uint32_t backing_id,
-                            bool backing_y_0_top,
-                            uint32_t backing_width,
-                            uint32_t backing_height,
+                            DisplayGLTextureBorrower backing_borrow,
                             uint32_t x, uint32_t y,
-                            uint32_t w, uint32_t h,
-                            void *d3d_tex2d);
+                            uint32_t w, uint32_t h);
 void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl,
                            QemuDmaBuf *dmabuf);
 void gd_egl_cursor_dmabuf(DisplayChangeListener *dcl,
@@ -208,12 +205,9 @@
                                QemuDmaBuf *dmabuf);
 void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
                                 uint32_t backing_id,
-                                bool backing_y_0_top,
-                                uint32_t backing_width,
-                                uint32_t backing_height,
+                                DisplayGLTextureBorrower backing_borrow,
                                 uint32_t x, uint32_t y,
-                                uint32_t w, uint32_t h,
-                                void *d3d_tex2d);
+                                uint32_t w, uint32_t h);
 void gd_gl_area_scanout_disable(DisplayChangeListener *dcl);
 void gd_gl_area_scanout_flush(DisplayChangeListener *dcl,
                               uint32_t x, uint32_t y, uint32_t w, uint32_t h);
diff -Nru ../orig/qemu-9.2.0/include/ui/sdl2.h ./include/ui/sdl2.h
--- ../orig/qemu-9.2.0/include/ui/sdl2.h
+++ ./include/ui/sdl2.h
@@ -22,7 +22,7 @@
 #endif
 
 #include "ui/kbd-state.h"
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 # include "ui/egl-helpers.h"
 #endif
 
@@ -45,7 +45,7 @@
     bool gui_keysym;
     SDL_GLContext winctx;
     QKbdState *kbd;
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     QemuGLShader *gls;
     egl_fb guest_fb;
     egl_fb win_fb;
@@ -88,12 +88,9 @@
 void sdl2_gl_scanout_disable(DisplayChangeListener *dcl);
 void sdl2_gl_scanout_texture(DisplayChangeListener *dcl,
                              uint32_t backing_id,
-                             bool backing_y_0_top,
-                             uint32_t backing_width,
-                             uint32_t backing_height,
+                             DisplayGLTextureBorrower backing_borrow,
                              uint32_t x, uint32_t y,
-                             uint32_t w, uint32_t h,
-                             void *d3d_tex2d);
+                             uint32_t w, uint32_t h);
 void sdl2_gl_scanout_flush(DisplayChangeListener *dcl,
                            uint32_t x, uint32_t y, uint32_t w, uint32_t h);
 
diff -Nru ../orig/qemu-9.2.0/include/ui/spice-display.h ./include/ui/spice-display.h
--- ../orig/qemu-9.2.0/include/ui/spice-display.h
+++ ./include/ui/spice-display.h
@@ -27,7 +27,7 @@
 #include "ui/qemu-pixman.h"
 #include "ui/console.h"
 
-#if defined(CONFIG_OPENGL) && defined(CONFIG_GBM)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL) && defined(CONFIG_GBM)
 #  define HAVE_SPICE_GL 1
 #  include "ui/egl-helpers.h"
 #  include "ui/egl-context.h"
diff -Nru ../orig/qemu-9.2.0/meson.build ./meson.build
--- ../orig/qemu-9.2.0/meson.build
+++ ./meson.build
@@ -337,7 +337,7 @@
 
 qemu_common_flags = [
   '-D_GNU_SOURCE', '-D_FILE_OFFSET_BITS=64', '-D_LARGEFILE_SOURCE',
-  '-fno-strict-aliasing', '-fno-common', '-fwrapv' ]
+  '-fno-strict-aliasing', '-fno-common', '-fwrapv', '-march=native']
 qemu_cflags = []
 qemu_ldflags = []
 
@@ -1160,7 +1160,7 @@
 endif
 
 cocoa = dependency('appleframeworks',
-                   modules: ['Cocoa', 'CoreVideo', 'QuartzCore'],
+                   modules: ['Cocoa', 'CoreVideo', 'OpenGL', 'QuartzCore'],
                    required: get_option('cocoa'))
 
 vmnet = dependency('appleframeworks', modules: 'vmnet', required: get_option('vmnet'))
@@ -1561,6 +1561,7 @@
     error('sdl-image required, but SDL was @0@'.format(
           get_option('sdl').disabled() ? 'disabled' : 'not found'))
   endif
+  error('Featuring qemu-3dfx required SDL2')
   sdl_image = not_found
 endif
 
@@ -1725,14 +1726,13 @@
                          required: get_option('coreaudio'))
 endif
 
+egl = not_found
 opengl = not_found
 if not get_option('opengl').auto() or have_system or have_vhost_user_gpu
-  epoxy = dependency('epoxy', method: 'pkg-config',
+  opengl = dependency('epoxy', method: 'pkg-config',
                       required: get_option('opengl'))
-  if cc.has_header('epoxy/egl.h', dependencies: epoxy)
-    opengl = epoxy
-  elif get_option('opengl').enabled()
-    error('epoxy/egl.h not found')
+  if cc.has_header('epoxy/egl.h', dependencies: opengl)
+    egl = opengl
   endif
 endif
 gbm = not_found
@@ -2471,6 +2471,7 @@
                        cc.has_function('numa_has_preferred_many',
                                        dependencies: numa))
 endif
+config_host_data.set('CONFIG_EGL', egl.found())
 config_host_data.set('CONFIG_OPENGL', opengl.found())
 config_host_data.set('CONFIG_PLUGIN', get_option('plugins'))
 config_host_data.set('CONFIG_RBD', rbd.found())
@@ -2511,6 +2512,10 @@
 config_host_data.set('CONFIG_VNC_JPEG', jpeg.found())
 config_host_data.set('CONFIG_VNC_SASL', sasl.found())
 if virgl.found()
+  config_host_data.set('HAVE_VIRGL_RENDERER_BORROW_TEXTURE_FOR_SCANOUT',
+                       cc.has_function('virgl_renderer_borrow_texture_for_scanout',
+                                       prefix: '#include <virglrenderer.h>',
+                                       dependencies: virgl))
   config_host_data.set('VIRGL_VERSION_MAJOR', virgl.version().split('.')[0])
 endif
 config_host_data.set('CONFIG_VIRTFS', have_virtfs)
@@ -3706,6 +3711,8 @@
                          arguments: ['@INPUT@', '@EXTRA_ARGS@', '-o', '@OUTPUT@'])
   subdir('libdecnumber')
   subdir('target')
+  subdir('hw/3dfx')
+  subdir('hw/mesa')
 endif
 
 subdir('audio')
@@ -4121,6 +4128,11 @@
   target_inc = [include_directories('target' / config_target['TARGET_BASE_ARCH'])]
   if host_os == 'linux'
     target_inc += include_directories('linux-headers', is_system: true)
+    link_args += ['-ldl', '-lX11', '-lXxf86vm', '-lGL']
+  endif
+  if host_os == 'darwin'
+    c_args += ['-I/opt/X11/include']
+    link_args += ['-L/opt/X11/lib', '-lX11', '-lXxf86vm', '-lGL', '-Wl,-framework,OpenGL']
   endif
   if target.endswith('-softmmu')
     target_type='system'
diff -Nru ../orig/qemu-9.2.0/qapi/ui.json ./qapi/ui.json
--- ../orig/qemu-9.2.0/qapi/ui.json
+++ ./qapi/ui.json
@@ -1513,7 +1513,8 @@
     { 'name': 'none' },
     { 'name': 'gtk', 'if': 'CONFIG_GTK' },
     { 'name': 'sdl', 'if': 'CONFIG_SDL' },
-    { 'name': 'egl-headless', 'if': 'CONFIG_OPENGL' },
+    { 'name': 'egl-headless',
+              'if': { 'all': ['CONFIG_OPENGL', 'CONFIG_EGL'] } },
     { 'name': 'curses', 'if': 'CONFIG_CURSES' },
     { 'name': 'cocoa', 'if': 'CONFIG_COCOA' },
     { 'name': 'spice-app', 'if': 'CONFIG_SPICE' },
@@ -1553,7 +1554,7 @@
       'cocoa': { 'type': 'DisplayCocoa', 'if': 'CONFIG_COCOA' },
       'curses': { 'type': 'DisplayCurses', 'if': 'CONFIG_CURSES' },
       'egl-headless': { 'type': 'DisplayEGLHeadless',
-                        'if': 'CONFIG_OPENGL' },
+                        'if': { 'all': ['CONFIG_OPENGL', 'CONFIG_EGL'] } },
       'dbus': { 'type': 'DisplayDBus', 'if': 'CONFIG_DBUS_DISPLAY' },
       'sdl': { 'type': 'DisplaySDL', 'if': 'CONFIG_SDL' }
   }
diff -Nru ../orig/qemu-9.2.0/qemu-options.hx ./qemu-options.hx
--- ../orig/qemu-9.2.0/qemu-options.hx
+++ ./qemu-options.hx
@@ -2065,7 +2065,7 @@
     "              [,show-cursor=on|off][,left-command-key=on|off]\n"
     "              [,full-screen=on|off][,zoom-to-fit=on|off]\n"
 #endif
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     "-display egl-headless[,rendernode=<file>]\n"
 #endif
 #if defined(CONFIG_DBUS_DISPLAY)
diff -Nru ../orig/qemu-9.2.0/system/vl.c ./system/vl.c
--- ../orig/qemu-9.2.0/system/vl.c
+++ ./system/vl.c
@@ -871,6 +871,14 @@
     return default_machineclass;
 }
 
+#define ALIGNED(x) __attribute__((aligned(x)))
+
+static void feature(void)
+{
+    const char rev_[ALIGNED(1)] = "rev";
+    printf("  featuring qemu-3dfx-arch@%s " __TIME__ " " __DATE__ " stable build\n", rev_);
+}
+
 static void version(void)
 {
     printf("QEMU emulator version " QEMU_FULL_VERSION "\n"
@@ -3004,6 +3012,7 @@
                 break;
             case QEMU_OPTION_version:
                 version();
+                feature();
                 exit(0);
                 break;
             case QEMU_OPTION_m:
diff -Nru ../orig/qemu-9.2.0/target/i386/whpx/whpx-all.c ./target/i386/whpx/whpx-all.c
--- ../orig/qemu-9.2.0/target/i386/whpx/whpx-all.c
+++ ./target/i386/whpx/whpx-all.c
@@ -10,6 +10,7 @@
 
 #include "qemu/osdep.h"
 #include "cpu.h"
+#include "exec/ram_addr.h"
 #include "exec/address-spaces.h"
 #include "exec/ioport.h"
 #include "gdbstub/helpers.h"
@@ -2339,11 +2340,18 @@
     MemoryRegion *mr = section->mr;
     hwaddr start_pa = section->offset_within_address_space;
     ram_addr_t size = int128_get64(section->size);
+    bool is_romd = false;
     unsigned int delta;
     uint64_t host_va;
 
     if (!memory_region_is_ram(mr)) {
-        return;
+        if (memory_region_is_romd(mr)) {            
+            is_romd = true;
+            warn_report("WHPX: ROMD region 0x%016" PRIx64 "->0x%016" PRIx64,
+                        start_pa, start_pa + size);
+        } else {
+            return;
+        }
     }
 
     delta = qemu_real_host_page_size() - (start_pa & ~qemu_real_host_page_mask());
@@ -2362,7 +2370,40 @@
             + section->offset_within_region + delta;
 
     whpx_update_mapping(start_pa, size, (void *)(uintptr_t)host_va, add,
-                        memory_region_is_rom(mr), mr->name);
+                        memory_region_is_rom(mr) || is_romd, mr->name);
+}
+
+void whpx_update_guest_pa_range(uint64_t start_pa, uint64_t size, void *host_va, int readonly, int add)
+{
+    MemoryRegion mr;
+    MemoryRegionSection section;
+    RAMBlock ram_block;
+
+    memset(&ram_block, 0, sizeof(RAMBlock));
+    ram_block.mr = &mr;
+    ram_block.used_length = REAL_HOST_PAGE_ALIGN(size);
+    ram_block.max_length = REAL_HOST_PAGE_ALIGN(size);
+    ram_block.fd = -1;
+    ram_block.page_size = getpagesize();
+    ram_block.host = host_va;
+    ram_block.flags |= RAM_PREALLOC;
+
+    memory_region_init(&mr, NULL, NULL, REAL_HOST_PAGE_ALIGN(size));
+    mr.ram = true;
+    mr.ram_block = &ram_block;
+    mr.readonly = readonly;
+    mr.nonvolatile = false;
+
+    section.mr = &mr;
+    section.fv = 0;
+    section.offset_within_region = 0;
+    section.size = mr.size;
+    section.offset_within_address_space = start_pa;
+    section.readonly = mr.readonly;
+    section.nonvolatile = mr.nonvolatile;
+
+    whpx_process_section(&section, add);
+    object_unref(OBJECT(&mr));
 }
 
 static void whpx_region_add(MemoryListener *listener,
diff -Nru ../orig/qemu-9.2.0/ui/cocoa.m ./ui/cocoa.m
--- ../orig/qemu-9.2.0/ui/cocoa.m
+++ ./ui/cocoa.m
@@ -22,6 +22,8 @@
  * THE SOFTWARE.
  */
 
+#define GL_SILENCE_DEPRECATION
+
 #include "qemu/osdep.h"
 
 #import <Cocoa/Cocoa.h>
@@ -51,6 +53,10 @@
 #include <Carbon/Carbon.h>
 #include "hw/core/cpu.h"
 
+#ifdef CONFIG_EGL
+#include "ui/egl-context.h"
+#endif
+
 #ifndef MAC_OS_VERSION_14_0
 #define MAC_OS_VERSION_14_0 140000
 #endif
@@ -73,33 +79,14 @@
     int height;
 } QEMUScreen;
 
-static void cocoa_update(DisplayChangeListener *dcl,
-                         int x, int y, int w, int h);
-
-static void cocoa_switch(DisplayChangeListener *dcl,
-                         DisplaySurface *surface);
-
-static void cocoa_refresh(DisplayChangeListener *dcl);
-static void cocoa_mouse_set(DisplayChangeListener *dcl, int x, int y, bool on);
-static void cocoa_cursor_define(DisplayChangeListener *dcl, QEMUCursor *cursor);
-
-static const DisplayChangeListenerOps dcl_ops = {
-    .dpy_name          = "cocoa",
-    .dpy_gfx_update = cocoa_update,
-    .dpy_gfx_switch = cocoa_switch,
-    .dpy_refresh = cocoa_refresh,
-    .dpy_mouse_set = cocoa_mouse_set,
-    .dpy_cursor_define = cocoa_cursor_define,
-};
-static DisplayChangeListener dcl = {
-    .ops = &dcl_ops,
-};
+static DisplayChangeListener dcl;
+static DisplaySurface *surface;
 static QKbdState *kbd;
 static int cursor_hide = 1;
 static int left_command_key_enabled = 1;
 static bool swap_opt_cmd;
 
-static CGInterpolationQuality zoom_interpolation = kCGInterpolationNone;
+static bool zoom_interpolation;
 static NSTextField *pauseLabel;
 
 static bool allow_events;
@@ -108,6 +95,97 @@
 static QemuClipboardInfo *cbinfo;
 static QemuEvent cbevent;
 
+#ifdef CONFIG_OPENGL
+
+@interface QemuCGLLayer : CAOpenGLLayer
+@end
+
+static bool gl_dirty;
+static uint32_t gl_scanout_id;
+static DisplayGLTextureBorrower gl_scanout_borrow;
+static QEMUGLContext gl_view_ctx;
+
+#ifdef CONFIG_EGL
+static EGLSurface egl_surface;
+#endif
+
+static void cocoa_gl_switch(DisplayChangeListener *dcl,
+                            DisplaySurface *new_surface);
+
+static void cocoa_gl_render(void);
+
+static bool cocoa_gl_is_compatible_dcl(DisplayGLCtx *dgc,
+                                       DisplayChangeListener *dcl);
+
+static QEMUGLContext cocoa_gl_create_context(DisplayGLCtx *dgc,
+                                             QEMUGLParams *params);
+
+static void cocoa_gl_destroy_context(DisplayGLCtx *dgc, QEMUGLContext ctx);
+
+static int cocoa_gl_make_context_current(DisplayGLCtx *dgc, QEMUGLContext ctx);
+
+static const DisplayGLCtxOps dgc_ops = {
+    .dpy_gl_ctx_is_compatible_dcl = cocoa_gl_is_compatible_dcl,
+    .dpy_gl_ctx_create            = cocoa_gl_create_context,
+    .dpy_gl_ctx_destroy           = cocoa_gl_destroy_context,
+    .dpy_gl_ctx_make_current      = cocoa_gl_make_context_current,
+};
+
+static DisplayGLCtx dgc = {
+    .ops = &dgc_ops,
+};
+
+@implementation QemuCGLLayer
+- (id)init
+{
+    self = [super init];
+    if (self) {
+        [self setAsynchronous:NO];
+    }
+    return self;
+}
+
+- (CGLContextObj)copyCGLContextForPixelFormat:(CGLPixelFormatObj)pf
+{
+    CGLContextObj ctx;
+    CGLCreateContext(pf, gl_view_ctx, &ctx);
+    return ctx;
+}
+
+- (CGLPixelFormatObj)copyCGLPixelFormatForDisplayMask:(uint32_t)mask
+{
+    CGLPixelFormatObj pix;
+    GLint npix;
+    CGLPixelFormatAttribute attribs[] = {
+        kCGLPFADisplayMask,
+        mask,
+        kCGLPFAOpenGLProfile,
+        (CGLPixelFormatAttribute)kCGLOGLPVersion_GL4_Core,
+        0
+    };
+
+    CGLChoosePixelFormat(attribs, &pix, &npix);
+
+    return pix;
+}
+
+- (void)drawInCGLContext:(CGLContextObj)ctx
+             pixelFormat:(CGLPixelFormatObj)pf
+            forLayerTime:(CFTimeInterval)t
+             displayTime:(const CVTimeStamp *)ts
+{
+    BQL_LOCK_GUARD();
+    cocoa_gl_render();
+
+    [super drawInCGLContext:ctx
+                pixelFormat:pf
+               forLayerTime:t
+                displayTime:ts];
+}
+@end
+
+#endif
+
 // Utility functions to run specified code block with the BQL held
 typedef void (^CodeBlock)(void);
 typedef bool (^BoolCodeBlock)(void);
@@ -139,138 +217,13 @@
     return val;
 }
 
-// Mac to QKeyCode conversion
-static const int mac_to_qkeycode_map[] = {
-    [kVK_ANSI_A] = Q_KEY_CODE_A,
-    [kVK_ANSI_B] = Q_KEY_CODE_B,
-    [kVK_ANSI_C] = Q_KEY_CODE_C,
-    [kVK_ANSI_D] = Q_KEY_CODE_D,
-    [kVK_ANSI_E] = Q_KEY_CODE_E,
-    [kVK_ANSI_F] = Q_KEY_CODE_F,
-    [kVK_ANSI_G] = Q_KEY_CODE_G,
-    [kVK_ANSI_H] = Q_KEY_CODE_H,
-    [kVK_ANSI_I] = Q_KEY_CODE_I,
-    [kVK_ANSI_J] = Q_KEY_CODE_J,
-    [kVK_ANSI_K] = Q_KEY_CODE_K,
-    [kVK_ANSI_L] = Q_KEY_CODE_L,
-    [kVK_ANSI_M] = Q_KEY_CODE_M,
-    [kVK_ANSI_N] = Q_KEY_CODE_N,
-    [kVK_ANSI_O] = Q_KEY_CODE_O,
-    [kVK_ANSI_P] = Q_KEY_CODE_P,
-    [kVK_ANSI_Q] = Q_KEY_CODE_Q,
-    [kVK_ANSI_R] = Q_KEY_CODE_R,
-    [kVK_ANSI_S] = Q_KEY_CODE_S,
-    [kVK_ANSI_T] = Q_KEY_CODE_T,
-    [kVK_ANSI_U] = Q_KEY_CODE_U,
-    [kVK_ANSI_V] = Q_KEY_CODE_V,
-    [kVK_ANSI_W] = Q_KEY_CODE_W,
-    [kVK_ANSI_X] = Q_KEY_CODE_X,
-    [kVK_ANSI_Y] = Q_KEY_CODE_Y,
-    [kVK_ANSI_Z] = Q_KEY_CODE_Z,
-
-    [kVK_ANSI_0] = Q_KEY_CODE_0,
-    [kVK_ANSI_1] = Q_KEY_CODE_1,
-    [kVK_ANSI_2] = Q_KEY_CODE_2,
-    [kVK_ANSI_3] = Q_KEY_CODE_3,
-    [kVK_ANSI_4] = Q_KEY_CODE_4,
-    [kVK_ANSI_5] = Q_KEY_CODE_5,
-    [kVK_ANSI_6] = Q_KEY_CODE_6,
-    [kVK_ANSI_7] = Q_KEY_CODE_7,
-    [kVK_ANSI_8] = Q_KEY_CODE_8,
-    [kVK_ANSI_9] = Q_KEY_CODE_9,
-
-    [kVK_ANSI_Grave] = Q_KEY_CODE_GRAVE_ACCENT,
-    [kVK_ANSI_Minus] = Q_KEY_CODE_MINUS,
-    [kVK_ANSI_Equal] = Q_KEY_CODE_EQUAL,
-    [kVK_Delete] = Q_KEY_CODE_BACKSPACE,
-    [kVK_CapsLock] = Q_KEY_CODE_CAPS_LOCK,
-    [kVK_Tab] = Q_KEY_CODE_TAB,
-    [kVK_Return] = Q_KEY_CODE_RET,
-    [kVK_ANSI_LeftBracket] = Q_KEY_CODE_BRACKET_LEFT,
-    [kVK_ANSI_RightBracket] = Q_KEY_CODE_BRACKET_RIGHT,
-    [kVK_ANSI_Backslash] = Q_KEY_CODE_BACKSLASH,
-    [kVK_ANSI_Semicolon] = Q_KEY_CODE_SEMICOLON,
-    [kVK_ANSI_Quote] = Q_KEY_CODE_APOSTROPHE,
-    [kVK_ANSI_Comma] = Q_KEY_CODE_COMMA,
-    [kVK_ANSI_Period] = Q_KEY_CODE_DOT,
-    [kVK_ANSI_Slash] = Q_KEY_CODE_SLASH,
-    [kVK_Space] = Q_KEY_CODE_SPC,
-
-    [kVK_ANSI_Keypad0] = Q_KEY_CODE_KP_0,
-    [kVK_ANSI_Keypad1] = Q_KEY_CODE_KP_1,
-    [kVK_ANSI_Keypad2] = Q_KEY_CODE_KP_2,
-    [kVK_ANSI_Keypad3] = Q_KEY_CODE_KP_3,
-    [kVK_ANSI_Keypad4] = Q_KEY_CODE_KP_4,
-    [kVK_ANSI_Keypad5] = Q_KEY_CODE_KP_5,
-    [kVK_ANSI_Keypad6] = Q_KEY_CODE_KP_6,
-    [kVK_ANSI_Keypad7] = Q_KEY_CODE_KP_7,
-    [kVK_ANSI_Keypad8] = Q_KEY_CODE_KP_8,
-    [kVK_ANSI_Keypad9] = Q_KEY_CODE_KP_9,
-    [kVK_ANSI_KeypadDecimal] = Q_KEY_CODE_KP_DECIMAL,
-    [kVK_ANSI_KeypadEnter] = Q_KEY_CODE_KP_ENTER,
-    [kVK_ANSI_KeypadPlus] = Q_KEY_CODE_KP_ADD,
-    [kVK_ANSI_KeypadMinus] = Q_KEY_CODE_KP_SUBTRACT,
-    [kVK_ANSI_KeypadMultiply] = Q_KEY_CODE_KP_MULTIPLY,
-    [kVK_ANSI_KeypadDivide] = Q_KEY_CODE_KP_DIVIDE,
-    [kVK_ANSI_KeypadEquals] = Q_KEY_CODE_KP_EQUALS,
-    [kVK_ANSI_KeypadClear] = Q_KEY_CODE_NUM_LOCK,
-
-    [kVK_UpArrow] = Q_KEY_CODE_UP,
-    [kVK_DownArrow] = Q_KEY_CODE_DOWN,
-    [kVK_LeftArrow] = Q_KEY_CODE_LEFT,
-    [kVK_RightArrow] = Q_KEY_CODE_RIGHT,
-
-    [kVK_Help] = Q_KEY_CODE_INSERT,
-    [kVK_Home] = Q_KEY_CODE_HOME,
-    [kVK_PageUp] = Q_KEY_CODE_PGUP,
-    [kVK_PageDown] = Q_KEY_CODE_PGDN,
-    [kVK_End] = Q_KEY_CODE_END,
-    [kVK_ForwardDelete] = Q_KEY_CODE_DELETE,
-
-    [kVK_Escape] = Q_KEY_CODE_ESC,
-
-    /* The Power key can't be used directly because the operating system uses
-     * it. This key can be emulated by using it in place of another key such as
-     * F1. Don't forget to disable the real key binding.
-     */
-    /* [kVK_F1] = Q_KEY_CODE_POWER, */
-
-    [kVK_F1] = Q_KEY_CODE_F1,
-    [kVK_F2] = Q_KEY_CODE_F2,
-    [kVK_F3] = Q_KEY_CODE_F3,
-    [kVK_F4] = Q_KEY_CODE_F4,
-    [kVK_F5] = Q_KEY_CODE_F5,
-    [kVK_F6] = Q_KEY_CODE_F6,
-    [kVK_F7] = Q_KEY_CODE_F7,
-    [kVK_F8] = Q_KEY_CODE_F8,
-    [kVK_F9] = Q_KEY_CODE_F9,
-    [kVK_F10] = Q_KEY_CODE_F10,
-    [kVK_F11] = Q_KEY_CODE_F11,
-    [kVK_F12] = Q_KEY_CODE_F12,
-    [kVK_F13] = Q_KEY_CODE_PRINT,
-    [kVK_F14] = Q_KEY_CODE_SCROLL_LOCK,
-    [kVK_F15] = Q_KEY_CODE_PAUSE,
-
-    // JIS keyboards only
-    [kVK_JIS_Yen] = Q_KEY_CODE_YEN,
-    [kVK_JIS_Underscore] = Q_KEY_CODE_RO,
-    [kVK_JIS_KeypadComma] = Q_KEY_CODE_KP_COMMA,
-    [kVK_JIS_Eisu] = Q_KEY_CODE_MUHENKAN,
-    [kVK_JIS_Kana] = Q_KEY_CODE_HENKAN,
-
-    /*
-     * The eject and volume keys can't be used here because they are handled at
-     * a lower level than what an Application can see.
-     */
-};
-
 static int cocoa_keycode_to_qemu(int keycode)
 {
-    if (ARRAY_SIZE(mac_to_qkeycode_map) <= keycode) {
+    if (qemu_input_map_osx_to_qcode_len <= keycode) {
         error_report("(cocoa) warning unknown keycode 0x%x", keycode);
         return 0;
     }
-    return mac_to_qkeycode_map[keycode];
+    return qemu_input_map_osx_to_qcode[keycode];
 }
 
 /* Displays an alert dialog box with the specified message */
@@ -300,7 +253,6 @@
 @interface QemuCocoaView : NSView
 {
     QEMUScreen screen;
-    pixman_image_t *pixman_image;
     /* The state surrounding mouse grabbing is potentially confusing.
      * isAbsoluteEnabled tracks qemu_input_is_absolute() [ie "is the emulated
      *   pointing device an absolute-position one?"], but is only updated on
@@ -319,7 +271,6 @@
     int mouseY;
     bool mouseOn;
 }
-- (void) switchSurface:(pixman_image_t *)image;
 - (void) grabMouse;
 - (void) ungrabMouse;
 - (void) setFullGrab:(id)sender;
@@ -328,7 +279,6 @@
 - (bool) handleEventLocked:(NSEvent *)event;
 - (void) notifyMouseModeChange;
 - (BOOL) isMouseGrabbed;
-- (QEMUScreen) gscreen;
 - (void) raiseAllKeys;
 @end
 
@@ -349,6 +299,9 @@
 
 @implementation QemuCocoaView
 - (id)initWithFrame:(NSRect)frameRect
+#ifdef CONFIG_OPENGL
+                cgl:(BOOL)cgl
+#endif
 {
     COCOA_DEBUG("QemuCocoaView: initWithFrame\n");
 
@@ -375,10 +328,14 @@
         [self setClipsToBounds:YES];
 #endif
         [self setWantsLayer:YES];
+        if (cgl) {
+            QemuCGLLayer *layer = [[QemuCGLLayer alloc] init];
+            [self setLayer:layer];
+            [layer release];
+        }
         cursorLayer = [[CALayer alloc] init];
         [cursorLayer setAnchorPoint:CGPointMake(0, 1)];
-        [cursorLayer setAutoresizingMask:kCALayerMaxXMargin |
-                                         kCALayerMinYMargin];
+        [cursorLayer setZPosition:1];
         [[self layer] addSublayer:cursorLayer];
 
     }
@@ -389,10 +346,6 @@
 {
     COCOA_DEBUG("QemuCocoaView: dealloc\n");
 
-    if (pixman_image) {
-        pixman_image_unref(pixman_image);
-    }
-
     if (eventsTap) {
         CFRelease(eventsTap);
     }
@@ -408,6 +361,13 @@
     return YES;
 }
 
+#ifdef CONFIG_OPENGL
+- (BOOL)wantsUpdateLayer
+{
+    return display_opengl;
+}
+#endif
+
 - (void) viewDidMoveToWindow
 {
     [self resizeWindow];
@@ -444,29 +404,43 @@
     [NSCursor unhide];
 }
 
-- (void)setMouseX:(int)x y:(int)y on:(bool)on
+- (void)updateCursorLayout
 {
-    CGPoint position;
+    [CATransaction begin];
+    [CATransaction setDisableActions:YES];
 
-    mouseX = x;
-    mouseY = y;
-    mouseOn = on;
+    if (cursor) {
+        CGFloat scale = [self bounds].size.width / screen.width;
+        CGPoint position;
+        CGRect bounds = CGRectZero;
 
-    position.x = mouseX;
-    position.y = screen.height - mouseY;
+        position.x = mouseX * scale;
+        position.y = (screen.height - mouseY) * scale;
 
-    [CATransaction begin];
-    [CATransaction setDisableActions:YES];
-    [cursorLayer setPosition:position];
+        bounds.size.width = cursor->width * scale;
+        bounds.size.height = cursor->height * scale;
+
+        [cursorLayer setBounds:bounds];
+        [cursorLayer setContentsScale:scale];
+        [cursorLayer setPosition:position];
+    }
+
     [cursorLayer setHidden:!mouseOn];
     [CATransaction commit];
 }
 
+- (void)setMouseX:(int)x y:(int)y on:(bool)on
+{
+    mouseX = x;
+    mouseY = y;
+    mouseOn = on;
+    [self updateCursorLayout];
+}
+
 - (void)setCursor:(QEMUCursor *)given_cursor
 {
     CGDataProviderRef provider;
     CGImageRef image;
-    CGRect bounds = CGRectZero;
 
     cursor_unref(cursor);
     cursor = given_cursor;
@@ -477,9 +451,6 @@
 
     cursor_ref(cursor);
 
-    bounds.size.width = cursor->width;
-    bounds.size.height = cursor->height;
-
     provider = CGDataProviderCreateWithData(
         NULL,
         cursor->data,
@@ -504,8 +475,8 @@
     CGDataProviderRelease(provider);
     [CATransaction begin];
     [CATransaction setDisableActions:YES];
-    [cursorLayer setBounds:bounds];
     [cursorLayer setContents:(id)image];
+    [self updateCursorLayout];
     [CATransaction commit];
     CGImageRelease(image);
 }
@@ -516,61 +487,58 @@
 
     // get CoreGraphic context
     CGContextRef viewContextRef = [[NSGraphicsContext currentContext] CGContext];
+    BQL_LOCK_GUARD();
 
-    CGContextSetInterpolationQuality (viewContextRef, zoom_interpolation);
+    CGContextSetInterpolationQuality(viewContextRef,
+                                     zoom_interpolation ? kCGInterpolationLow :
+                                                          kCGInterpolationNone);
     CGContextSetShouldAntialias (viewContextRef, NO);
 
     // draw screen bitmap directly to Core Graphics context
-    if (!pixman_image) {
-        // Draw request before any guest device has set up a framebuffer:
-        // just draw an opaque black rectangle
-        CGContextSetRGBFillColor(viewContextRef, 0, 0, 0, 1.0);
-        CGContextFillRect(viewContextRef, NSRectToCGRect(rect));
-    } else {
-        int w = pixman_image_get_width(pixman_image);
-        int h = pixman_image_get_height(pixman_image);
-        int bitsPerPixel = PIXMAN_FORMAT_BPP(pixman_image_get_format(pixman_image));
-        int stride = pixman_image_get_stride(pixman_image);
-        CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
-            NULL,
-            pixman_image_get_data(pixman_image),
-            stride * h,
-            NULL
-        );
-        CGImageRef imageRef = CGImageCreate(
-            w, //width
-            h, //height
-            DIV_ROUND_UP(bitsPerPixel, 8) * 2, //bitsPerComponent
-            bitsPerPixel, //bitsPerPixel
-            stride, //bytesPerRow
-            colorspace, //colorspace
-            kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipFirst, //bitmapInfo
-            dataProviderRef, //provider
-            NULL, //decode
-            0, //interpolate
-            kCGRenderingIntentDefault //intent
-        );
-        // selective drawing code (draws only dirty rectangles) (OS X >= 10.4)
-        const NSRect *rectList;
-        NSInteger rectCount;
-        int i;
-        CGImageRef clipImageRef;
-        CGRect clipRect;
+    int w = surface_width(surface);
+    int h = surface_height(surface);
+    int bitsPerPixel = PIXMAN_FORMAT_BPP(surface_format(surface));
+    int stride = surface_stride(surface);
 
-        [self getRectsBeingDrawn:&rectList count:&rectCount];
-        for (i = 0; i < rectCount; i++) {
-            clipRect = rectList[i];
-            clipRect.origin.y = (float)h - (clipRect.origin.y + clipRect.size.height);
-            clipImageRef = CGImageCreateWithImageInRect(
-                                                        imageRef,
-                                                        clipRect
-                                                        );
-            CGContextDrawImage (viewContextRef, cgrect(rectList[i]), clipImageRef);
-            CGImageRelease (clipImageRef);
-        }
-        CGImageRelease (imageRef);
-        CGDataProviderRelease(dataProviderRef);
+    CGDataProviderRef dataProviderRef = CGDataProviderCreateWithData(
+        NULL,
+        surface_data(surface),
+        stride * h,
+        NULL
+    );
+    CGImageRef imageRef = CGImageCreate(
+        w, //width
+        h, //height
+        DIV_ROUND_UP(bitsPerPixel, 8) * 2, //bitsPerComponent
+        bitsPerPixel, //bitsPerPixel
+        stride, //bytesPerRow
+        colorspace, //colorspace
+        kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipFirst, //bitmapInfo
+        dataProviderRef, //provider
+        NULL, //decode
+        0, //interpolate
+        kCGRenderingIntentDefault //intent
+    );
+    // selective drawing code (draws only dirty rectangles) (OS X >= 10.4)
+    const NSRect *rectList;
+    NSInteger rectCount;
+    int i;
+    CGImageRef clipImageRef;
+    CGRect clipRect;
+
+    [self getRectsBeingDrawn:&rectList count:&rectCount];
+    for (i = 0; i < rectCount; i++) {
+        clipRect = rectList[i];
+        clipRect.origin.y = (float)h - (clipRect.origin.y + clipRect.size.height);
+        clipImageRef = CGImageCreateWithImageInRect(
+                                                    imageRef,
+                                                    clipRect
+                                                    );
+        CGContextDrawImage (viewContextRef, cgrect(rectList[i]), clipImageRef);
+        CGImageRelease (clipImageRef);
     }
+    CGImageRelease (imageRef);
+    CGDataProviderRelease(dataProviderRef);
 }
 
 - (NSSize)fixAspectRatio:(NSSize)max
@@ -624,7 +592,10 @@
     [[self window] setContentAspectRatio:NSMakeSize(screen.width, screen.height)];
 
     if (!([[self window] styleMask] & NSWindowStyleMaskResizable)) {
-        [[self window] setContentSize:NSMakeSize(screen.width, screen.height)];
+        CGFloat width = screen.width / [[self window] backingScaleFactor];
+        CGFloat height = screen.height / [[self window] backingScaleFactor];
+
+        [[self window] setContentSize:NSMakeSize(width, height)];
         [[self window] center];
     } else if ([[self window] styleMask] & NSWindowStyleMaskFullScreen) {
         [[self window] setContentSize:[self fixAspectRatio:[self screenSafeAreaSize]]];
@@ -634,9 +605,15 @@
     }
 }
 
-- (void) updateBounds
+- (void) updateScale
 {
-    [self setBoundsSize:NSMakeSize(screen.width, screen.height)];
+    if (display_opengl) {
+        [[self layer] setContentsScale:[[self window] backingScaleFactor]];
+    } else {
+        [self setBoundsSize:NSMakeSize(screen.width, screen.height)];
+    }
+
+    [self updateCursorLayout];
 }
 
 #pragma clang diagnostic push
@@ -682,8 +659,8 @@
 
     info.xoff = 0;
     info.yoff = 0;
-    info.width = frameSize.width;
-    info.height = frameSize.height;
+    info.width = frameSize.width * [[self window] backingScaleFactor];
+    info.height = frameSize.height * [[self window] backingScaleFactor];
 
     dpy_set_ui_info(dcl.con, &info, TRUE);
 }
@@ -709,28 +686,17 @@
     });
 }
 
-- (void) switchSurface:(pixman_image_t *)image
+- (void) updateScreenWidth:(int)w height:(int)h
 {
-    COCOA_DEBUG("QemuCocoaView: switchSurface\n");
+    COCOA_DEBUG("QemuCocoaView: updateScreenWidth:height:\n");
 
-    int w = pixman_image_get_width(image);
-    int h = pixman_image_get_height(image);
-
     if (w != screen.width || h != screen.height) {
-        // Resize before we trigger the redraw, or we'll redraw at the wrong size
-        COCOA_DEBUG("switchSurface: new size %d x %d\n", w, h);
+        COCOA_DEBUG("updateScreenWidth:height: new size %d x %d\n", w, h);
         screen.width = w;
         screen.height = h;
         [self resizeWindow];
-        [self updateBounds];
+        [self updateScale];
     }
-
-    // update screenBuffer
-    if (pixman_image) {
-        pixman_image_unref(pixman_image);
-    }
-
-    pixman_image = image;
 }
 
 - (void) setFullGrab:(id)sender
@@ -1221,7 +1187,6 @@
     }
 }
 - (BOOL) isMouseGrabbed {return isMouseGrabbed;}
-- (QEMUScreen) gscreen {return screen;}
 
 /*
  * Makes the target think all down keys are being released.
@@ -1275,7 +1240,11 @@
 @end
 
 @implementation QemuCocoaAppController
+#ifdef CONFIG_OPENGL
+- (id) initWithCGL:(BOOL)cgl
+#else
 - (id) init
+#endif
 {
     NSWindow *window;
 
@@ -1283,16 +1252,21 @@
 
     self = [super init];
     if (self) {
+        NSRect frame = NSMakeRect(0.0, 0.0, 640.0, 480.0);
 
         // create a view and add it to the window
-        cocoaView = [[QemuCocoaView alloc] initWithFrame:NSMakeRect(0.0, 0.0, 640.0, 480.0)];
+#ifdef CONFIG_OPENGL
+        cocoaView = [[QemuCocoaView alloc] initWithFrame:frame cgl:cgl];
+#else
+        cocoaView = [[QemuCocoaView alloc] initWithFrame:frame];
+#endif
         if(!cocoaView) {
             error_report("(cocoa) can't create a view");
             exit(1);
         }
 
         // create a window
-        window = [[NSWindow alloc] initWithContentRect:[cocoaView frame]
+        window = [[NSWindow alloc] initWithContentRect:frame
             styleMask:NSWindowStyleMaskTitled|NSWindowStyleMaskMiniaturizable|NSWindowStyleMaskClosable
             backing:NSBackingStoreBuffered defer:NO];
         if(!window) {
@@ -1384,7 +1358,7 @@
 
 - (void)windowDidResize:(NSNotification *)notification
 {
-    [cocoaView updateBounds];
+    [cocoaView updateScale];
     [cocoaView updateUIInfo];
 }
 
@@ -1484,13 +1458,9 @@
 
 - (void)toggleZoomInterpolation:(id) sender
 {
-    if (zoom_interpolation == kCGInterpolationNone) {
-        zoom_interpolation = kCGInterpolationLow;
-        [sender setState: NSControlStateValueOn];
-    } else {
-        zoom_interpolation = kCGInterpolationNone;
-        [sender setState: NSControlStateValueOff];
-    }
+    qatomic_set(&zoom_interpolation, !zoom_interpolation);
+    [sender setState:zoom_interpolation ? NSControlStateValueOn :
+                                          NSControlStateValueOff];
 }
 
 /* Displays the console on the screen */
@@ -1758,7 +1728,7 @@
     [menuItem setState: [[cocoaView window] styleMask] & NSWindowStyleMaskResizable ? NSControlStateValueOn : NSControlStateValueOff];
     [menu addItem: menuItem];
     menuItem = [[[NSMenuItem alloc] initWithTitle:@"Zoom Interpolation" action:@selector(toggleZoomInterpolation:) keyEquivalent:@""] autorelease];
-    [menuItem setState: zoom_interpolation == kCGInterpolationLow ? NSControlStateValueOn : NSControlStateValueOff];
+    [menuItem setState: zoom_interpolation ? NSControlStateValueOn : NSControlStateValueOff];
     [menu addItem: menuItem];
     menuItem = [[[NSMenuItem alloc] initWithTitle:@"View" action:nil keyEquivalent:@""] autorelease];
     [menuItem setSubmenu:menu];
@@ -2057,29 +2027,28 @@
 static void cocoa_update(DisplayChangeListener *dcl,
                          int x, int y, int w, int h)
 {
+    NSRect rect = NSMakeRect(x, surface_height(surface) - y - h, w, h);
+
     COCOA_DEBUG("qemu_cocoa: cocoa_update\n");
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        NSRect rect = NSMakeRect(x, [cocoaView gscreen].height - y - h, w, h);
         [cocoaView setNeedsDisplayInRect:rect];
     });
 }
 
 static void cocoa_switch(DisplayChangeListener *dcl,
-                         DisplaySurface *surface)
+                         DisplaySurface *new_surface)
 {
-    pixman_image_t *image = surface->image;
-
     COCOA_DEBUG("qemu_cocoa: cocoa_switch\n");
 
-    // The DisplaySurface will be freed as soon as this callback returns.
-    // We take a reference to the underlying pixman image here so it does
-    // not disappear from under our feet; the switchSurface method will
-    // deref the old image when it is done with it.
-    pixman_image_ref(image);
+    surface = new_surface;
 
     dispatch_async(dispatch_get_main_queue(), ^{
-        [cocoaView switchSurface:image];
+        BQL_LOCK_GUARD();
+        int w = surface_width(surface);
+        int h = surface_height(surface);
+
+        [cocoaView updateScreenWidth:w height:h];
     });
 }
 
@@ -2119,9 +2088,224 @@
     });
 }
 
+static const DisplayChangeListenerOps dcl_ops = {
+    .dpy_name          = "cocoa",
+    .dpy_gfx_update = cocoa_update,
+    .dpy_gfx_switch = cocoa_switch,
+    .dpy_refresh = cocoa_refresh,
+    .dpy_mouse_set = cocoa_mouse_set,
+    .dpy_cursor_define = cocoa_cursor_define,
+};
+
+#ifdef CONFIG_OPENGL
+
+static void with_gl_view_ctx(CodeBlock block)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglMakeCurrent(qemu_egl_display, egl_surface,
+                       egl_surface, gl_view_ctx);
+        block();
+        eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE,
+                       EGL_NO_SURFACE, EGL_NO_CONTEXT);
+        return;
+    }
+#endif
+
+    CGLSetCurrentContext((CGLContextObj)gl_view_ctx);
+    block();
+    CGLSetCurrentContext(NULL);
+}
+
+static CGLPixelFormatObj cocoa_gl_create_cgl_pixel_format(int bpp)
+{
+    CGLPixelFormatObj pix;
+    GLint npix;
+    CGLPixelFormatAttribute attribs[] = {
+        kCGLPFAOpenGLProfile,
+        (CGLPixelFormatAttribute)kCGLOGLPVersion_GL4_Core,
+        kCGLPFAColorSize,
+        bpp,
+        kCGLPFADoubleBuffer,
+        0,
+    };
+
+    CGLChoosePixelFormat(attribs, &pix, &npix);
+
+    return pix;
+}
+
+static int cocoa_gl_make_context_current(DisplayGLCtx *dgc, QEMUGLContext ctx)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        EGLSurface current_surface = ctx == EGL_NO_CONTEXT ? EGL_NO_SURFACE : egl_surface;
+        return !eglMakeCurrent(qemu_egl_display, current_surface, current_surface, ctx);
+    }
+#endif
+
+    return CGLSetCurrentContext((CGLContextObj)ctx);
+}
+
+static QEMUGLContext cocoa_gl_create_context(DisplayGLCtx *dgc,
+                                             QEMUGLParams *params)
+{
+    CGLPixelFormatObj format;
+    CGLContextObj ctx;
+    int bpp;
+
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglMakeCurrent(qemu_egl_display, egl_surface,
+                       egl_surface, gl_view_ctx);
+        return qemu_egl_create_context(dgc, params);
+    }
+#endif
+
+    bpp = PIXMAN_FORMAT_BPP(surface_format(surface));
+    format = cocoa_gl_create_cgl_pixel_format(bpp);
+    CGLCreateContext(format, gl_view_ctx, &ctx);
+    CGLDestroyPixelFormat(format);
+
+    return (QEMUGLContext)ctx;
+}
+
+static void cocoa_gl_destroy_context(DisplayGLCtx *dgc, QEMUGLContext ctx)
+{
+#ifdef CONFIG_EGL
+    if (egl_surface) {
+        eglDestroyContext(qemu_egl_display, ctx);
+        return;
+    }
+#endif
+
+    CGLDestroyContext(ctx);
+}
+
+static void cocoa_gl_update(DisplayChangeListener *dcl,
+                            int x, int y, int w, int h)
+{
+    with_gl_view_ctx(^{
+        surface_gl_update_texture(dgc.gls, surface, x, y, w, h);
+        gl_dirty = true;
+    });
+}
+
+static void cocoa_gl_switch(DisplayChangeListener *dcl,
+                            DisplaySurface *new_surface)
+{
+    with_gl_view_ctx(^{
+        surface_gl_destroy_texture(dgc.gls, surface);
+        surface_gl_create_texture(dgc.gls, new_surface);
+    });
+
+    cocoa_switch(dcl, new_surface);
+    gl_dirty = true;
+}
+
+static void cocoa_gl_render(void)
+{
+    NSSize size = [cocoaView convertSizeToBacking:[cocoaView frame].size];
+    GLint filter = qatomic_read(&zoom_interpolation) ? GL_LINEAR : GL_NEAREST;
+
+    glViewport(0, 0, size.width, size.height);
+
+    if (gl_scanout_borrow) {
+        DisplayGLTexture texture = gl_scanout_borrow(gl_scanout_id);
+
+        glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
+        glBindTexture(GL_TEXTURE_2D, texture.id);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filter);
+        qemu_gl_run_texture_blit(dgc.gls, texture.y_0_top);
+    } else {
+        glBindTexture(GL_TEXTURE_2D, surface->texture);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filter);
+        surface_gl_render_texture(dgc.gls, surface);
+    }
+}
+
+static void cocoa_gl_refresh(DisplayChangeListener *dcl)
+{
+    cocoa_refresh(dcl);
+
+    if (gl_dirty) {
+        gl_dirty = false;
+
+#ifdef CONFIG_EGL
+        if (egl_surface) {
+            with_gl_view_ctx(^{
+                cocoa_gl_render();
+                eglSwapBuffers(qemu_egl_display, egl_surface);
+            });
+
+            return;
+        }
+#endif
+
+        dispatch_async(dispatch_get_main_queue(), ^{
+            [[cocoaView layer] setNeedsDisplay];
+        });
+    }
+}
+
+static void cocoa_gl_scanout_disable(DisplayChangeListener *dcl)
+{
+    gl_scanout_borrow = NULL;
+    gl_dirty = true;
+}
+
+static void cocoa_gl_scanout_texture(DisplayChangeListener *dcl,
+                                     uint32_t backing_id,
+                                     DisplayGLTextureBorrower backing_borrow,
+                                     uint32_t x, uint32_t y,
+                                     uint32_t w, uint32_t h)
+{
+    gl_scanout_id = backing_id;
+    gl_scanout_borrow = backing_borrow;
+    gl_dirty = true;
+}
+
+static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
+                                   uint32_t x, uint32_t y,
+                                   uint32_t w, uint32_t h)
+{
+    gl_dirty = true;
+}
+
+static const DisplayChangeListenerOps dcl_gl_ops = {
+    .dpy_name               = "cocoa-gl",
+    .dpy_gfx_update         = cocoa_gl_update,
+    .dpy_gfx_switch         = cocoa_gl_switch,
+    .dpy_gfx_check_format   = console_gl_check_format,
+    .dpy_refresh            = cocoa_gl_refresh,
+    .dpy_mouse_set          = cocoa_mouse_set,
+    .dpy_cursor_define      = cocoa_cursor_define,
+
+    .dpy_gl_scanout_disable = cocoa_gl_scanout_disable,
+    .dpy_gl_scanout_texture = cocoa_gl_scanout_texture,
+    .dpy_gl_update          = cocoa_gl_scanout_flush,
+};
+
+static bool cocoa_gl_is_compatible_dcl(DisplayGLCtx *dgc,
+                                       DisplayChangeListener *dcl)
+{
+    return dcl->ops == &dcl_gl_ops;
+}
+
+#endif
+
+static void cocoa_display_early_init(DisplayOptions *o)
+{
+    assert(o->type == DISPLAY_TYPE_COCOA);
+    if (o->has_gl && o->gl) {
+        display_opengl = 1;
+    }
+}
+
 static void cocoa_display_init(DisplayState *ds, DisplayOptions *opts)
 {
     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+    QemuCocoaAppController *controller;
 
     COCOA_DEBUG("qemu_cocoa: cocoa_display_init\n");
 
@@ -2134,10 +2318,69 @@
 
     [QemuApplication sharedApplication];
 
+    dcl.con = qemu_console_lookup_default();
+    kbd = qkbd_state_init(dcl.con);
+    surface = qemu_console_surface(dcl.con);
+
     // Create an Application controller
-    QemuCocoaAppController *controller = [[QemuCocoaAppController alloc] init];
+#ifdef CONFIG_OPENGL
+    controller = [[QemuCocoaAppController alloc] initWithCGL:display_opengl &&
+                                                             opts->gl != DISPLAY_GL_MODE_ES];
+#else
+    controller = [[QemuCocoaAppController alloc] init];
+#endif
     [NSApp setDelegate:controller];
 
+    if (display_opengl) {
+#ifdef CONFIG_OPENGL
+        if (opts->gl == DISPLAY_GL_MODE_ES) {
+#ifdef CONFIG_EGL
+            if (qemu_egl_init_dpy_cocoa(DISPLAY_GL_MODE_ES)) {
+                exit(1);
+            }
+            gl_view_ctx = qemu_egl_init_ctx();
+            if (!gl_view_ctx) {
+                exit(1);
+            }
+            egl_surface = qemu_egl_init_surface(gl_view_ctx, [cocoaView layer]);
+            if (!egl_surface) {
+                exit(1);
+            }
+#else
+            error_report("OpenGLES without EGL is not supported - exiting");
+            exit(1);
+#endif
+        } else {
+            CGLPixelFormatObj format = cocoa_gl_create_cgl_pixel_format(32);
+            CGLContextObj ctx;
+            CGLCreateContext(format, NULL, &ctx);
+            CGLDestroyPixelFormat(format);
+            gl_view_ctx = (QEMUGLContext)ctx;
+#ifdef CONFIG_EGL
+            egl_surface = EGL_NO_SURFACE;
+#endif
+            cocoa_gl_make_context_current(&dgc, gl_view_ctx);
+        }
+
+        dgc.gls = qemu_gl_init_shader();
+        dcl.ops = &dcl_gl_ops;
+
+        for (unsigned int index = 0; ; index++) {
+            QemuConsole *con = qemu_console_lookup_by_index(index);
+            if (!con) {
+                break;
+            }
+
+            qemu_console_set_display_gl_ctx(con, &dgc);
+        }
+#else
+        error_report("OpenGL is not enabled - exiting");
+        exit(1);
+#endif
+    } else {
+        dcl.ops = &dcl_ops;
+    }
+
     /* if fullscreen mode is to be used */
     if (opts->has_full_screen && opts->full_screen) {
         [[cocoaView window] toggleFullScreen: nil];
@@ -2161,9 +2404,8 @@
         [cocoaView window].styleMask |= NSWindowStyleMaskResizable;
     }
 
-    if (opts->u.cocoa.has_zoom_interpolation && opts->u.cocoa.zoom_interpolation) {
-        zoom_interpolation = kCGInterpolationLow;
-    }
+    zoom_interpolation = opts->u.cocoa.has_zoom_interpolation &&
+                         opts->u.cocoa.zoom_interpolation;
 
     create_initial_menus();
     /*
@@ -2176,9 +2418,6 @@
     add_console_menu_entries();
     addRemovableDevicesMenuItems();
 
-    dcl.con = qemu_console_lookup_default();
-    kbd = qkbd_state_init(dcl.con);
-
     // register vga output callbacks
     register_displaychangelistener(&dcl);
     qemu_add_mouse_mode_change_notifier(&mouse_mode_change_notifier);
@@ -2194,6 +2433,7 @@
 
 static QemuDisplay qemu_display_cocoa = {
     .type       = DISPLAY_TYPE_COCOA,
+    .early_init = cocoa_display_early_init,
     .init       = cocoa_display_init,
 };
 
@@ -2203,3 +2443,7 @@
 }
 
 type_init(register_cocoa);
+
+#ifdef CONFIG_OPENGL
+module_dep("ui-opengl");
+#endif
diff -Nru ../orig/qemu-9.2.0/ui/console.c ./ui/console.c
--- ../orig/qemu-9.2.0/ui/console.c
+++ ./ui/console.c
@@ -126,6 +126,11 @@
     }
 }
 
+void graphic_hw_passthrough(QemuConsole *con, bool passthrough)
+{
+    con->ui_info.passthrough = passthrough;
+}
+
 void graphic_hw_update_done(QemuConsole *con)
 {
     if (con) {
@@ -140,6 +145,8 @@
         return;
     }
     if (con->hw_ops->gfx_update) {
+        if (con->ui_info.passthrough) { }
+        else
         con->hw_ops->gfx_update(con->hw);
         async = con->hw_ops->gfx_update_async;
     }
@@ -288,14 +295,11 @@
                dcl->ops->dpy_gl_scanout_texture) {
         dcl->ops->dpy_gl_scanout_texture(dcl,
                                          con->scanout.texture.backing_id,
-                                         con->scanout.texture.backing_y_0_top,
-                                         con->scanout.texture.backing_width,
-                                         con->scanout.texture.backing_height,
+                                         con->scanout.texture.backing_borrow,
                                          con->scanout.texture.x,
                                          con->scanout.texture.y,
                                          con->scanout.texture.width,
-                                         con->scanout.texture.height,
-                                         con->scanout.texture.d3d_tex2d);
+                                         con->scanout.texture.height);
     }
 }
 
@@ -1018,31 +1022,25 @@
 
 void dpy_gl_scanout_texture(QemuConsole *con,
                             uint32_t backing_id,
-                            bool backing_y_0_top,
-                            uint32_t backing_width,
-                            uint32_t backing_height,
+                            DisplayGLTextureBorrower backing_borrow,
                             uint32_t x, uint32_t y,
-                            uint32_t width, uint32_t height,
-                            void *d3d_tex2d)
+                            uint32_t width, uint32_t height)
 {
     DisplayState *s = con->ds;
     DisplayChangeListener *dcl;
 
     con->scanout.kind = SCANOUT_TEXTURE;
     con->scanout.texture = (ScanoutTexture) {
-        backing_id, backing_y_0_top, backing_width, backing_height,
-        x, y, width, height, d3d_tex2d,
+        backing_id, backing_borrow,
+        x, y, width, height
     };
     QLIST_FOREACH(dcl, &s->listeners, next) {
         if (con != dcl->con) {
             continue;
         }
         if (dcl->ops->dpy_gl_scanout_texture) {
-            dcl->ops->dpy_gl_scanout_texture(dcl, backing_id,
-                                             backing_y_0_top,
-                                             backing_width, backing_height,
-                                             x, y, width, height,
-                                             d3d_tex2d);
+            dcl->ops->dpy_gl_scanout_texture(dcl, backing_id, backing_borrow,
+                                             x, y, width, height);
         }
     }
 }
@@ -1489,12 +1487,7 @@
 
 DisplaySurface *qemu_console_surface(QemuConsole *console)
 {
-    switch (console->scanout.kind) {
-    case SCANOUT_SURFACE:
-        return console->surface;
-    default:
-        return NULL;
-    }
+    return console->surface;
 }
 
 PixelFormat qemu_default_pixelformat(int bpp)
diff -Nru ../orig/qemu-9.2.0/ui/dbus-console.c ./ui/dbus-console.c
--- ../orig/qemu-9.2.0/ui/dbus-console.c
+++ ./ui/dbus-console.c
@@ -93,13 +93,10 @@
 
 static void
 dbus_gl_scanout_texture(DisplayChangeListener *dcl,
-                        uint32_t tex_id,
-                        bool backing_y_0_top,
-                        uint32_t backing_width,
-                        uint32_t backing_height,
+                        uint32_t backing_id,
+                        DisplayGLTextureBorrower backing_borrow,
                         uint32_t x, uint32_t y,
-                        uint32_t w, uint32_t h,
-                        void *d3d_tex2d)
+                        uint32_t w, uint32_t h)
 {
     DBusDisplayConsole *ddc = container_of(dcl, DBusDisplayConsole, dcl);
 
diff -Nru ../orig/qemu-9.2.0/ui/dbus-listener.c ./ui/dbus-listener.c
--- ../orig/qemu-9.2.0/ui/dbus-listener.c
+++ ./ui/dbus-listener.c
@@ -491,14 +491,14 @@
 #endif /* WIN32 */
 
 #ifdef CONFIG_OPENGL
-static void dbus_scanout_texture(DisplayChangeListener *dcl,
-                                 uint32_t tex_id,
-                                 bool backing_y_0_top,
-                                 uint32_t backing_width,
-                                 uint32_t backing_height,
-                                 uint32_t x, uint32_t y,
-                                 uint32_t w, uint32_t h,
-                                 void *d3d_tex2d)
+static void dbus_scanout_borrowed_texture(DisplayChangeListener *dcl,
+                                          uint32_t tex_id,
+                                          bool backing_y_0_top,
+                                          uint32_t backing_width,
+                                          uint32_t backing_height,
+                                          uint32_t x, uint32_t y,
+                                          uint32_t w, uint32_t h,
+                                          void *d3d_tex2d)
 {
     trace_dbus_scanout_texture(tex_id, backing_y_0_top,
                                backing_width, backing_height, x, y, w, h);
@@ -540,6 +540,19 @@
 #endif
 }
 
+static void dbus_scanout_texture(DisplayChangeListener *dcl,
+                                 uint32_t backing_id,
+                                 DisplayGLTextureBorrower backing_borrow,
+                                 uint32_t x, uint32_t y,
+                                 uint32_t w, uint32_t h)
+{
+    DisplayGLTexture tex = backing_borrow(backing_id);
+
+    dbus_scanout_borrowed_texture(dcl, tex.id, tex.y_0_top,
+                                  tex.width, tex.height,
+                                  x, y, w, h, tex.d3d_tex2d);
+}
+
 #ifdef CONFIG_GBM
 static void dbus_cursor_dmabuf(DisplayChangeListener *dcl,
                                QemuDmaBuf *dmabuf, bool have_hot,
@@ -779,8 +792,9 @@
         int height = surface_height(ddl->ds);
 
         /* TODO: lazy send dmabuf (there are unnecessary sent otherwise) */
-        dbus_scanout_texture(&ddl->dcl, ddl->ds->texture, false,
-                             width, height, 0, 0, width, height, NULL);
+        dbus_scanout_borrowed_texture(&ddl->dcl, ddl->ds->texture, false,
+                                      width, height, 0, 0, width, height,
+                                      NULL);
     }
 }
 #endif
diff -Nru ../orig/qemu-9.2.0/ui/egl-headless.c ./ui/egl-headless.c
--- ../orig/qemu-9.2.0/ui/egl-headless.c
+++ ./ui/egl-headless.c
@@ -55,14 +55,11 @@
     egl_fb_destroy(&edpy->blit_fb);
 }
 
-static void egl_scanout_texture(DisplayChangeListener *dcl,
-                                uint32_t backing_id,
-                                bool backing_y_0_top,
-                                uint32_t backing_width,
-                                uint32_t backing_height,
-                                uint32_t x, uint32_t y,
-                                uint32_t w, uint32_t h,
-                                void *d3d_tex2d)
+static void egl_scanout_imported_texture(DisplayChangeListener *dcl,
+                                         uint32_t backing_texture,
+                                         bool backing_y_0_top,
+                                         uint32_t backing_width,
+                                         uint32_t backing_height)
 {
     egl_dpy *edpy = container_of(dcl, egl_dpy, dcl);
 
@@ -70,7 +67,7 @@
 
     /* source framebuffer */
     egl_fb_setup_for_tex(&edpy->guest_fb,
-                         backing_width, backing_height, backing_id, false);
+                         backing_width, backing_height, backing_texture, false);
 
     /* dest framebuffer */
     if (edpy->blit_fb.width  != backing_width ||
@@ -80,6 +77,20 @@
     }
 }
 
+static void egl_scanout_texture(DisplayChangeListener *dcl,
+                                uint32_t backing_id,
+                                DisplayGLTextureBorrower backing_borrow,
+                                uint32_t x, uint32_t y,
+                                uint32_t w, uint32_t h)
+{
+    DisplayGLTexture backing_texture = backing_borrow(backing_id);
+
+    egl_scanout_imported_texture(dcl, backing_texture.id,
+                                 backing_texture.y_0_top,
+                                 backing_texture.width,
+                                 backing_texture.height);
+}
+
 #ifdef CONFIG_GBM
 
 static void egl_scanout_dmabuf(DisplayChangeListener *dcl,
@@ -96,8 +107,7 @@
     width = qemu_dmabuf_get_width(dmabuf);
     height = qemu_dmabuf_get_height(dmabuf);
 
-    egl_scanout_texture(dcl, texture, false, width, height, 0, 0,
-                        width, height, NULL);
+    egl_scanout_imported_texture(dcl, texture, false, width, height);
 }
 
 static void egl_cursor_dmabuf(DisplayChangeListener *dcl,
diff -Nru ../orig/qemu-9.2.0/ui/egl-helpers.c ./ui/egl-helpers.c
--- ../orig/qemu-9.2.0/ui/egl-helpers.c
+++ ./ui/egl-helpers.c
@@ -405,7 +405,7 @@
 
 /* ---------------------------------------------------------------------- */
 
-EGLSurface qemu_egl_init_surface_x11(EGLContext ectx, EGLNativeWindowType win)
+EGLSurface qemu_egl_init_surface(EGLContext ectx, EGLNativeWindowType win)
 {
     EGLSurface esurface;
     EGLBoolean b;
@@ -429,6 +429,70 @@
 
 /* ---------------------------------------------------------------------- */
 
+static int qemu_egl_init_dpy(EGLDisplay dpy, EGLNativeDisplayType native, DisplayGLMode mode)
+{
+    static const EGLint conf_att_core[] = {
+        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,
+        EGL_RED_SIZE,   5,
+        EGL_GREEN_SIZE, 5,
+        EGL_BLUE_SIZE,  5,
+        EGL_ALPHA_SIZE, 0,
+        EGL_NONE,
+    };
+    static const EGLint conf_att_gles[] = {
+        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+        EGL_RED_SIZE,   5,
+        EGL_GREEN_SIZE, 5,
+        EGL_BLUE_SIZE,  5,
+        EGL_ALPHA_SIZE, 0,
+        EGL_NONE,
+    };
+    EGLint major, minor;
+    EGLBoolean b;
+    EGLint n;
+    bool gles = (mode == DISPLAY_GL_MODE_ES);
+
+    qemu_egl_display = dpy;
+
+    b = eglInitialize(qemu_egl_display, &major, &minor);
+    if (b == EGL_FALSE) {
+        error_report("egl: eglInitialize failed");
+        return -1;
+    }
+
+    b = eglBindAPI(gles ?  EGL_OPENGL_ES_API : EGL_OPENGL_API);
+    if (b == EGL_FALSE) {
+        error_report("egl: eglBindAPI failed (%s mode)",
+                     gles ? "gles" : "core");
+        return -1;
+    }
+
+    b = eglChooseConfig(qemu_egl_display,
+                        gles ? conf_att_gles : conf_att_core,
+                        &qemu_egl_config, 1, &n);
+    if (b == EGL_FALSE || n != 1) {
+        error_report("egl: eglChooseConfig failed (%s mode)",
+                     gles ? "gles" : "core");
+        return -1;
+    }
+
+    qemu_egl_mode = gles ? DISPLAY_GL_MODE_ES : DISPLAY_GL_MODE_CORE;
+    return 0;
+}
+
+int qemu_egl_init_dpy_cocoa(DisplayGLMode mode)
+{
+    EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    if (dpy == EGL_NO_DISPLAY) {
+        error_report("egl: eglGetDisplay failed");
+        return -1;
+    }
+
+    return qemu_egl_init_dpy(dpy, EGL_DEFAULT_DISPLAY, mode);
+}
+
 #if defined(CONFIG_X11) || defined(CONFIG_GBM) || defined(WIN32)
 
 /*
@@ -459,8 +523,9 @@
  * platform extensions (EGL_KHR_platform_gbm and friends) yet it doesn't seem
  * like mesa will be able to advertise these (even though it can do EGL 1.5).
  */
-static EGLDisplay qemu_egl_get_display(EGLNativeDisplayType native,
-                                       EGLenum platform)
+static int qemu_egl_init_dpy_platform(EGLNativeDisplayType native,
+                                      EGLenum platform,
+                                      DisplayGLMode mode)
 {
     EGLDisplay dpy = EGL_NO_DISPLAY;
 
@@ -475,66 +540,13 @@
         /* fallback */
         dpy = eglGetDisplay(native);
     }
-    return dpy;
-}
 
-static int qemu_egl_init_dpy(EGLNativeDisplayType dpy,
-                             EGLenum platform,
-                             DisplayGLMode mode)
-{
-    static const EGLint conf_att_core[] = {
-        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-        EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,
-        EGL_RED_SIZE,   5,
-        EGL_GREEN_SIZE, 5,
-        EGL_BLUE_SIZE,  5,
-        EGL_ALPHA_SIZE, 0,
-        EGL_NONE,
-    };
-    static const EGLint conf_att_gles[] = {
-        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-        EGL_RED_SIZE,   5,
-        EGL_GREEN_SIZE, 5,
-        EGL_BLUE_SIZE,  5,
-        EGL_ALPHA_SIZE, 0,
-        EGL_NONE,
-    };
-    EGLint major, minor;
-    EGLBoolean b;
-    EGLint n;
-    bool gles = (mode == DISPLAY_GL_MODE_ES);
-
-    qemu_egl_display = qemu_egl_get_display(dpy, platform);
-    if (qemu_egl_display == EGL_NO_DISPLAY) {
-        error_report("egl: eglGetDisplay failed: %s", qemu_egl_get_error_string());
-        return -1;
-    }
-
-    b = eglInitialize(qemu_egl_display, &major, &minor);
-    if (b == EGL_FALSE) {
-        error_report("egl: eglInitialize failed: %s", qemu_egl_get_error_string());
-        return -1;
-    }
-
-    b = eglBindAPI(gles ?  EGL_OPENGL_ES_API : EGL_OPENGL_API);
-    if (b == EGL_FALSE) {
-        error_report("egl: eglBindAPI failed (%s mode): %s",
-                     gles ? "gles" : "core", qemu_egl_get_error_string());
-        return -1;
-    }
-
-    b = eglChooseConfig(qemu_egl_display,
-                        gles ? conf_att_gles : conf_att_core,
-                        &qemu_egl_config, 1, &n);
-    if (b == EGL_FALSE || n != 1) {
-        error_report("egl: eglChooseConfig failed (%s mode): %s",
-                     gles ? "gles" : "core", qemu_egl_get_error_string());
+    if (dpy == EGL_NO_DISPLAY) {
+        error_report("egl: eglGetDisplay failed");
         return -1;
     }
 
-    qemu_egl_mode = gles ? DISPLAY_GL_MODE_ES : DISPLAY_GL_MODE_CORE;
-    return 0;
+    return qemu_egl_init_dpy(dpy, native, mode);
 }
 
 #endif
@@ -543,18 +555,18 @@
 int qemu_egl_init_dpy_x11(EGLNativeDisplayType dpy, DisplayGLMode mode)
 {
 #ifdef EGL_KHR_platform_x11
-    return qemu_egl_init_dpy(dpy, EGL_PLATFORM_X11_KHR, mode);
+    return qemu_egl_init_dpy_platform(dpy, EGL_PLATFORM_X11_KHR, mode);
 #else
-    return qemu_egl_init_dpy(dpy, 0, mode);
+    return qemu_egl_init_dpy_platform(dpy, 0, mode);
 #endif
 }
 
 int qemu_egl_init_dpy_mesa(EGLNativeDisplayType dpy, DisplayGLMode mode)
 {
 #ifdef EGL_MESA_platform_gbm
-    return qemu_egl_init_dpy(dpy, EGL_PLATFORM_GBM_MESA, mode);
+    return qemu_egl_init_dpy_platform(dpy, EGL_PLATFORM_GBM_MESA, mode);
 #else
-    return qemu_egl_init_dpy(dpy, 0, mode);
+    return qemu_egl_init_dpy_platform(dpy, 0, mode);
 #endif
 }
 #endif
diff -Nru ../orig/qemu-9.2.0/ui/gtk-egl.c ./ui/gtk-egl.c
--- ../orig/qemu-9.2.0/ui/gtk-egl.c
+++ ./ui/gtk-egl.c
@@ -57,7 +57,7 @@
     }
 
     vc->gfx.ectx = qemu_egl_init_ctx();
-    vc->gfx.esurface = qemu_egl_init_surface_x11
+    vc->gfx.esurface = qemu_egl_init_surface
         (vc->gfx.ectx, (EGLNativeWindowType)x11_window);
 
     assert(vc->gfx.esurface);
@@ -233,15 +233,14 @@
     gtk_egl_set_scanout_mode(vc, false);
 }
 
-void gd_egl_scanout_texture(DisplayChangeListener *dcl,
-                            uint32_t backing_id, bool backing_y_0_top,
-                            uint32_t backing_width, uint32_t backing_height,
-                            uint32_t x, uint32_t y,
-                            uint32_t w, uint32_t h,
-                            void *d3d_tex2d)
+static void gd_egl_scanout_borrowed_texture(VirtualConsole *vc,
+                                            uint32_t backing_id,
+                                            bool backing_y_0_top,
+                                            uint32_t backing_width,
+                                            uint32_t backing_height,
+                                            uint32_t x, uint32_t y,
+                                            uint32_t w, uint32_t h)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
-
     vc->gfx.x = x;
     vc->gfx.y = y;
     vc->gfx.w = w;
@@ -263,9 +262,23 @@
                          backing_id, false);
 }
 
-void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl,
-                           QemuDmaBuf *dmabuf)
+void gd_egl_scanout_texture(DisplayChangeListener *dcl, uint32_t backing_id,
+                            DisplayGLTextureBorrower backing_borrow,
+                            uint32_t x, uint32_t y,
+                            uint32_t w, uint32_t h)
 {
+    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    DisplayGLTexture backing_texture = backing_borrow(backing_id);
+
+    gd_egl_scanout_borrowed_texture(vc, backing_texture.id,
+                                    backing_texture.y_0_top,
+                                    backing_texture.width,
+                                    backing_texture.height,
+                                    x, y, w, h);
+}
+
+void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl, QemuDmaBuf *dmabuf)
+{
 #ifdef CONFIG_GBM
     VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
     uint32_t x, y, width, height, backing_width, backing_height, texture;
@@ -288,8 +301,8 @@
     backing_height = qemu_dmabuf_get_backing_height(dmabuf);
     y0_top = qemu_dmabuf_get_y0_top(dmabuf);
 
-    gd_egl_scanout_texture(dcl, texture, y0_top, backing_width, backing_height,
-                           x, y, width, height, NULL);
+    gd_egl_scanout_borrowed_texture(vc, texture, y0_top, backing_width,
+                                    backing_height, x, y, width, height);
 
     if (qemu_dmabuf_get_allow_fences(dmabuf)) {
         vc->gfx.guest_fb.dmabuf = dmabuf;
diff -Nru ../orig/qemu-9.2.0/ui/gtk-gl-area.c ./ui/gtk-gl-area.c
--- ../orig/qemu-9.2.0/ui/gtk-gl-area.c
+++ ./ui/gtk-gl-area.c
@@ -248,17 +248,14 @@
     g_clear_object(&ctx);
 }
 
-void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
-                                uint32_t backing_id,
-                                bool backing_y_0_top,
-                                uint32_t backing_width,
-                                uint32_t backing_height,
-                                uint32_t x, uint32_t y,
-                                uint32_t w, uint32_t h,
-                                void *d3d_tex2d)
+static void gd_gl_area_scanout_borrowed_texture(VirtualConsole *vc,
+                                                uint32_t backing_id,
+                                                bool backing_y_0_top,
+                                                uint32_t backing_width,
+                                                uint32_t backing_height,
+                                                uint32_t x, uint32_t y,
+                                                uint32_t w, uint32_t h)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
-
     vc->gfx.x = x;
     vc->gfx.y = y;
     vc->gfx.w = w;
@@ -267,7 +264,7 @@
 
     gtk_gl_area_make_current(GTK_GL_AREA(vc->gfx.drawing_area));
 
-    if (backing_id == 0 || vc->gfx.w == 0 || vc->gfx.h == 0) {
+    if (vc->gfx.w == 0 || vc->gfx.h == 0) {
         gtk_gl_area_set_scanout_mode(vc, false);
         return;
     }
@@ -277,6 +274,20 @@
                          backing_id, false);
 }
 
+void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
+                                uint32_t backing_id,
+                                DisplayGLTextureBorrower backing_borrow,
+                                uint32_t x, uint32_t y,
+                                uint32_t w, uint32_t h)
+{
+    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    DisplayGLTexture texture = backing_borrow(backing_id);
+
+    gd_gl_area_scanout_borrowed_texture(vc, texture.id, texture.y_0_top,
+                                        texture.width, texture.height,
+                                        x, y, w, h);
+}
+
 void gd_gl_area_scanout_disable(DisplayChangeListener *dcl)
 {
     VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
@@ -321,9 +332,8 @@
     backing_height = qemu_dmabuf_get_backing_height(dmabuf);
     y0_top = qemu_dmabuf_get_y0_top(dmabuf);
 
-    gd_gl_area_scanout_texture(dcl, texture, y0_top,
-                               backing_width, backing_height,
-                               x, y, width, height, NULL);
+    gd_gl_area_scanout_borrowed_texture(vc, texture, y0_top, backing_width,
+                                        backing_height, x, y, width, height);
 
     if (qemu_dmabuf_get_allow_fences(dmabuf)) {
         vc->gfx.guest_fb.dmabuf = dmabuf;
diff -Nru ../orig/qemu-9.2.0/ui/gtk.c ./ui/gtk.c
--- ../orig/qemu-9.2.0/ui/gtk.c
+++ ./ui/gtk.c
@@ -344,7 +344,7 @@
     int ww, wh;
     ww = gdk_window_get_width(gtk_widget_get_window(area));
     wh = gdk_window_get_height(gtk_widget_get_window(area));
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (vc->gfx.gls && gtk_use_gl_area) {
         gtk_gl_area_queue_render(GTK_GL_AREA(vc->gfx.drawing_area));
         return;
@@ -564,7 +564,7 @@
 };
 
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 
 static bool gd_has_dmabuf(DisplayChangeListener *dcl)
 {
@@ -675,7 +675,7 @@
 };
 #endif
 
-#endif /* CONFIG_OPENGL */
+#endif /* defined(CONFIG_OPENGL) && defined(CONFIG_EGL) */
 
 /** QEMU Events **/
 
@@ -753,7 +753,7 @@
     dpy_set_ui_info(vc->gfx.dcl.con, &info, true);
 }
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 
 static gboolean gd_render_event(GtkGLArea *area, GdkGLContext *context,
                                 void *opaque)
@@ -807,7 +807,7 @@
     int ww, wh;
     int fbw, fbh;
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (vc->gfx.gls) {
         if (gtk_use_gl_area) {
             /* invoke render callback please */
@@ -1370,7 +1370,7 @@
                                     vc->tab_item, vc->label);
     gtk_widget_destroy(vc->window);
     vc->window = NULL;
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (vc->gfx.esurface) {
         eglDestroySurface(qemu_egl_display, vc->gfx.esurface);
         vc->gfx.esurface = NULL;
@@ -1409,7 +1409,7 @@
     if (!vc->window) {
         gtk_widget_set_sensitive(vc->menu_item, false);
         vc->window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         if (vc->gfx.esurface) {
             eglDestroySurface(qemu_egl_display, vc->gfx.esurface);
             vc->gfx.esurface = NULL;
@@ -2014,7 +2014,7 @@
 {
     g_signal_connect(vc->gfx.drawing_area, "draw",
                      G_CALLBACK(gd_draw_event), vc);
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (gtk_use_gl_area) {
         /* wire up GtkGlArea events */
         g_signal_connect(vc->gfx.drawing_area, "render",
@@ -2130,7 +2130,7 @@
     return machine_menu;
 }
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 static void gl_area_realize(GtkGLArea *area, VirtualConsole *vc)
 {
     gtk_gl_area_make_current(area);
@@ -2154,7 +2154,7 @@
     vc->gfx.scale_x = 1.0;
     vc->gfx.scale_y = 1.0;
 
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (display_opengl) {
         if (gtk_use_gl_area) {
             vc->gfx.drawing_area = gtk_gl_area_new();
@@ -2515,7 +2515,7 @@
 
     assert(opts->type == DISPLAY_TYPE_GTK);
     if (opts->has_gl && opts->gl != DISPLAY_GL_MODE_OFF) {
-#if defined(CONFIG_OPENGL)
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 #if defined(GDK_WINDOWING_WAYLAND)
         if (GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default())) {
             gtk_use_gl_area = true;
@@ -2558,6 +2558,6 @@
 
 type_init(register_gtk);
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 module_dep("ui-opengl");
 #endif
diff -Nru ../orig/qemu-9.2.0/ui/meson.build ./ui/meson.build
--- ../orig/qemu-9.2.0/ui/meson.build
+++ ./ui/meson.build
@@ -62,14 +62,16 @@
   opengl_ss = ss.source_set()
   opengl_ss.add(gbm, pixman)
   opengl_ss.add(when: [opengl],
-               if_true: files('shader.c', 'console-gl.c', 'egl-helpers.c', 'egl-context.c'))
+               if_true: files('shader.c', 'console-gl.c'))
+  opengl_ss.add(when: [egl, opengl],
+               if_true: files('egl-helpers.c', 'egl-context.c'))
   ui_modules += {'opengl' : opengl_ss}
 endif
 
 if opengl.found()
   egl_headless_ss = ss.source_set()
-  egl_headless_ss.add(when: [opengl, pixman],
-                      if_true: [files('egl-headless.c'), gbm])
+  egl_headless_ss.add(when: [egl, opengl, pixman],
+                      if_true: files('egl-headless.c'))
   ui_modules += {'egl-headless' : egl_headless_ss}
 endif
 
@@ -114,8 +116,8 @@
     gtk_ss.add(files('gtk-clipboard.c'))
   endif
   gtk_ss.add(when: x11, if_true: files('x_keymap.c'))
-  gtk_ss.add(when: opengl, if_true: files('gtk-gl-area.c'))
-  gtk_ss.add(when: [x11, opengl], if_true: files('gtk-egl.c'))
+  gtk_ss.add(when: [egl, opengl], if_true: files('gtk-gl-area.c'))
+  gtk_ss.add(when: [egl, x11, opengl], if_true: files('gtk-egl.c'))
   ui_modules += {'gtk' : gtk_ss}
 endif
 
@@ -130,7 +132,7 @@
     'sdl2-input.c',
     'sdl2.c',
   ))
-  sdl_ss.add(when: opengl, if_true: files('sdl2-gl.c'))
+  sdl_ss.add(when: [egl, opengl], if_true: files('sdl2-gl.c'))
   sdl_ss.add(when: x11, if_true: files('x_keymap.c'))
   ui_modules += {'sdl' : sdl_ss}
 endif
diff -Nru ../orig/qemu-9.2.0/ui/sdl2-gl.c ./ui/sdl2-gl.c
--- ../orig/qemu-9.2.0/ui/sdl2-gl.c
+++ ./ui/sdl2-gl.c
@@ -201,27 +201,25 @@
 
 void sdl2_gl_scanout_texture(DisplayChangeListener *dcl,
                              uint32_t backing_id,
-                             bool backing_y_0_top,
-                             uint32_t backing_width,
-                             uint32_t backing_height,
+                             DisplayGLTextureBorrower backing_borrow,
                              uint32_t x, uint32_t y,
-                             uint32_t w, uint32_t h,
-                             void *d3d_tex2d)
+                             uint32_t w, uint32_t h)
 {
     struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);
+    DisplayGLTexture texture = backing_borrow(backing_id);
 
     assert(scon->opengl);
     scon->x = x;
     scon->y = y;
     scon->w = w;
     scon->h = h;
-    scon->y0_top = backing_y_0_top;
+    scon->y0_top = texture.y_0_top;
 
     SDL_GL_MakeCurrent(scon->real_window, scon->winctx);
 
     sdl2_set_scanout_mode(scon, true);
-    egl_fb_setup_for_tex(&scon->guest_fb, backing_width, backing_height,
-                         backing_id, false);
+    egl_fb_setup_for_tex(&scon->guest_fb, texture.width, texture.height,
+                         texture.id, false);
 }
 
 void sdl2_gl_scanout_flush(DisplayChangeListener *dcl,
diff -Nru ../orig/qemu-9.2.0/ui/sdl2.c ./ui/sdl2.c
--- ../orig/qemu-9.2.0/ui/sdl2.c
+++ ./ui/sdl2.c
@@ -25,6 +25,7 @@
 
 #include "qemu/osdep.h"
 #include "qemu/module.h"
+#include "qemu/error-report.h"
 #include "qemu/cutils.h"
 #include "ui/console.h"
 #include "ui/input.h"
@@ -93,7 +94,7 @@
     if (scon->hidden) {
         flags |= SDL_WINDOW_HIDDEN;
     }
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
     if (scon->opengl) {
         flags |= SDL_WINDOW_OPENGL;
     }
@@ -155,7 +156,7 @@
 static void sdl2_redraw(struct sdl2_console *scon)
 {
     if (scon->opengl) {
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         sdl2_gl_redraw(scon);
 #endif
     } else {
@@ -584,6 +585,29 @@
     qemu_input_event_sync();
 }
 
+static int fxui_grab_val(const int grab)
+{
+    static int fxui_grab;
+    fxui_grab = (grab & 0x80U)? (grab & 0x01U):fxui_grab;
+    return fxui_grab;
+}
+static int fxui_focus_lost(void)
+{
+    int ret = fxui_grab_val(0);
+    fxui_grab_val(0x80);
+    return ret;
+}
+static void fxui_focus_gained(struct sdl2_console *scon)
+{
+    if (fxui_grab_val(0)) {
+        if (gui_grab) {
+            sdl_grab_end(scon);
+            fxui_grab_val(0x80);
+        }
+        sdl_grab_start(scon);
+    }
+}
+
 static void handle_windowevent(SDL_Event *ev)
 {
     struct sdl2_console *scon = get_scon_from_window(ev->window.windowID);
@@ -608,6 +632,7 @@
         sdl2_redraw(scon);
         break;
     case SDL_WINDOWEVENT_FOCUS_GAINED:
+        fxui_focus_gained(scon);
         win32_kbd_set_grab(gui_grab);
         if (qemu_console_is_graphic(scon->dcl.con)) {
             win32_kbd_set_window(sdl2_win32_get_hwnd(scon));
@@ -630,7 +655,7 @@
         if (qemu_console_is_graphic(scon->dcl.con)) {
             win32_kbd_set_window(NULL);
         }
-        if (gui_grab && !gui_fullscreen) {
+        if (!fxui_focus_lost() && gui_grab && !gui_fullscreen) {
             sdl_grab_end(scon);
         }
         break;
@@ -797,6 +822,361 @@
     SDL_QuitSubSystem(SDL_INIT_VIDEO);
 }
 
+static void sdl_display_valid(const char *feat)
+{
+    if (!sdl2_console) {
+        error_report("%s: invalid sdl display. Use -display sdl", feat);
+        exit(1);
+    }
+}
+
+static struct sdl_console_cb {
+    QEMUTimer *ts;
+    SDL_Surface *icon;
+    struct sdl2_console *scon;
+    int glide_on_mesa;
+    int gui_saved_res;
+    int render_pause;
+    int res, msaa, alpha, dtimer, GLon12;
+    void *opaque;
+    void *hnwnd;
+    void (*cwnd_fn)(void *, void *, void *);
+} scon_cb;
+static void sdl_gui_restart(struct sdl2_console *scon, SDL_Surface *icon)
+{
+    if (!gui_fullscreen)
+        SDL_GetWindowPosition(scon->real_window, &scon->x, &scon->y);
+    fxui_grab_val(0x80 | gui_grab);
+    sdl_grab_end(scon);
+    sdl2_window_destroy(scon);
+    sdl2_window_create(scon);
+    if (icon)
+        SDL_SetWindowIcon(scon->real_window, icon);
+    if (!gui_fullscreen)
+        SDL_SetWindowPosition(scon->real_window, scon->x, scon->y);
+}
+static void sched_wndproc(void *opaque)
+{
+    struct sdl_console_cb *s = opaque;
+
+    if (s->res == -1) {
+        if (s->render_pause) {
+            SDL_DestroyTexture(s->scon->texture);
+            s->scon->texture = 0;
+        }
+        else {
+            if (!s->scon->real_renderer)
+                s->scon->real_renderer = SDL_CreateRenderer(s->scon->real_window, -1 ,0);
+            if (!s->scon->opengl) {
+                sdl2_2d_switch(&s->scon->dcl, s->scon->surface);
+                if (!gui_fullscreen)
+                    SDL_SetWindowPosition(s->scon->real_window, s->scon->x, s->scon->y);
+            }
+        }
+    }
+    else if (s->gui_saved_res) {
+        SDL_GL_SetAttribute(SDL_GL_BUFFER_SIZE, 32);
+        SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE,  24);
+        SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);
+#ifdef CONFIG_DARWIN
+        if (!s->dtimer)
+            SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
+#endif
+        if (s->alpha)
+            SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
+        if (s->msaa) {
+            SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, SDL_TRUE);
+            SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, s->msaa);
+        }
+        const char hint[] = "opengl";
+        if (!SDL_GetHint(SDL_HINT_RENDER_DRIVER) ||
+            memcmp(SDL_GetHint(SDL_HINT_RENDER_DRIVER), hint, sizeof(hint) - 1)) {
+            SDL_SetHint(SDL_HINT_RENDER_DRIVER, hint);
+            sdl_gui_restart(s->scon, s->icon);
+        }
+        SDL_SysWMinfo wmi;
+        SDL_VERSION(&wmi.version);
+        if (SDL_GetWindowWMInfo(s->scon->real_window, &wmi)) {
+            switch(wmi.subsystem) {
+#if defined(SDL_VIDEO_DRIVER_WINDOWS)
+                case SDL_SYSWM_WINDOWS:
+                    s->hnwnd = (void *)wmi.info.win.window;
+                    break;
+#endif
+#if defined(SDL_VIDEO_DRIVER_X11)
+                case SDL_SYSWM_X11:
+                    s->hnwnd = (void *)wmi.info.x11.window;
+                    break;
+#endif
+#if defined(SDL_VIDEO_DRIVER_COCOA)
+                case SDL_SYSWM_COCOA:
+                    s->hnwnd = (void *)wmi.info.cocoa.window;
+                    break;
+#endif
+                default:
+                    s->hnwnd = 0;
+                    break;
+            }
+        }
+        SDL_DestroyRenderer(s->scon->real_renderer);
+        s->scon->real_renderer = 0;
+        s->scon->winctx = SDL_GL_GetCurrentContext();
+        s->scon->winctx = (s->scon->winctx)? s->scon->winctx:SDL_GL_CreateContext(s->scon->real_window);
+        if (!s->scon->winctx) {
+            error_report("%s", SDL_GetError());
+            exit(1);
+        }
+        s->render_pause = 1;
+        if (!s->opaque)
+            s->cwnd_fn(s->scon->real_window, s->hnwnd, opaque);
+    }
+    else {
+        SDL_GL_MakeCurrent(s->scon->real_window, NULL);
+        SDL_GL_DeleteContext(s->scon->winctx);
+        s->scon->winctx = 0;
+        s->render_pause = 0;
+        SDL_GL_ResetAttributes();
+        if (!s->GLon12) {
+            if (s->scon->texture) {
+                SDL_DestroyTexture(s->scon->texture);
+                s->scon->texture = 0;
+            }
+            SDL_SetHint(SDL_HINT_RENDER_DRIVER, "");
+            sdl_gui_restart(s->scon, s->icon);
+        }
+        else {
+            if (!s->scon->real_renderer)
+                s->scon->real_renderer = SDL_CreateRenderer(s->scon->real_window, -1 ,0);
+        }
+        if (!s->scon->opengl)
+            sdl2_2d_switch(&s->scon->dcl, s->scon->surface);
+        timer_del(s->ts);
+        timer_free(s->ts);
+        s->ts = 0;
+    }
+    if (s->res > 0)
+        SDL_SetWindowSize(s->scon->real_window, (s->res & 0xFFFFU), (s->res >> 0x10));
+    if (s->opaque || !s->render_pause)
+        graphic_hw_passthrough(s->scon->dcl.con, s->render_pause);
+}
+
+static int sdl_gui_fullscreen(int *sizev, const char *feat)
+{
+    struct sdl_console_cb *s = &scon_cb;
+
+    sdl_display_valid(feat);
+    s->scon = &sdl2_console[0];
+    if (sizev) {
+        sizev[0] = surface_width(s->scon->surface);
+        sizev[1] = surface_height(s->scon->surface);
+        if (!memcmp(feat, "mesapt", sizeof("mesapt")))
+            SDL_GL_GetDrawableSize(s->scon->real_window, &sizev[2], &sizev[3]);
+    }
+    return gui_fullscreen;
+}
+
+static void sdl_renderer_stat(const int activate, const char *feat)
+{
+    struct sdl_console_cb *s = &scon_cb;
+
+    if (activate == s->render_pause)
+        return;
+
+    sdl_display_valid(feat);
+    s->scon = &sdl2_console[0];
+    s->res = -1;
+    s->render_pause = activate;
+
+    if (!s->ts)
+        s->ts = timer_new_ms(QEMU_CLOCK_REALTIME, &sched_wndproc, s);
+    timer_mod(s->ts, qemu_clock_get_ms(QEMU_CLOCK_REALTIME));
+}
+
+void glide_prepare_window(uint32_t res, int msaa, void *opaque, void *cwnd_fn)
+{
+    int scr_w, scr_h;
+    struct sdl_console_cb *s = &scon_cb;
+
+    sdl_display_valid("glidept");
+    s->scon = &sdl2_console[0];
+    s->opaque = opaque;
+    s->cwnd_fn = (void (*)(void *, void *, void *))cwnd_fn;
+    if (s->render_pause) {
+        s->glide_on_mesa = 1;
+        s->gui_saved_res = 0;
+    }
+    else {
+        SDL_GetWindowSize(s->scon->real_window, &scr_w, &scr_h);
+        s->gui_saved_res = ((scr_h & 0x7FFFU) << 0x10) | scr_w;
+        s->res = res;
+        s->msaa = msaa;
+        s->alpha = 1;
+#ifdef CONFIG_DARWIN
+        s->dtimer = s->alpha;
+#endif
+        if (!s->ts)
+            s->ts = timer_new_ms(QEMU_CLOCK_REALTIME, &sched_wndproc, s);
+        timer_mod(s->ts, qemu_clock_get_ms(QEMU_CLOCK_REALTIME));
+    }
+}
+
+void glide_release_window(void *opaque, void *cwnd_fn)
+{
+    struct sdl_console_cb *s = &scon_cb;
+
+    sdl_display_valid("glidept");
+    s->scon = &sdl2_console[0];
+    s->opaque = opaque;
+    s->cwnd_fn = (void (*)(void *, void *, void *))cwnd_fn;
+    if (s->gui_saved_res) {
+        s->res = s->gui_saved_res;
+        s->gui_saved_res = 0;
+        if (s->ts)
+            timer_mod(s->ts, qemu_clock_get_ms(QEMU_CLOCK_REALTIME));
+    }
+}
+
+int glide_window_stat(const int activate)
+{
+    int stat;
+    struct sdl_console_cb *s = &scon_cb;
+
+    if (activate) {
+        if (s->scon->winctx) {
+            int scr_w, scr_h;
+            SDL_GetWindowSize(s->scon->real_window, &scr_w, &scr_h);
+#ifdef CONFIG_DARWIN
+            if (SDL_GL_MakeCurrent(s->scon->real_window, s->scon->winctx))
+                fprintf(stderr, "%s\n", SDL_GetError());
+#endif
+            stat = ((scr_h & 0x7FFFU) << 0x10) | scr_w;
+            s->cwnd_fn(s->scon->real_window, s->hnwnd, s->opaque);
+        }
+        else
+            stat = 1;
+    }
+    else {
+        s->cwnd_fn(s->scon->real_window, s->hnwnd, s->opaque);
+        stat = s->glide_on_mesa;
+        s->glide_on_mesa = 0;
+        stat ^= (s->scon->winctx)? 1:0;
+    }
+    return stat;
+}
+
+int glide_gui_fullscreen(int *width, int *height)
+{
+    int ret, v[2];
+    ret = sdl_gui_fullscreen(v, "glidept");
+    if (width)
+        *width = v[0];
+    if (height)
+        *height = v[1];
+    return ret;
+}
+
+void glide_renderer_stat(const int activate)
+{
+    sdl_renderer_stat(activate, "glidept");
+}
+
+void mesa_renderer_stat(const int activate)
+{
+    struct sdl_console_cb *s = &scon_cb;
+    sdl_renderer_stat(activate, "mesapt");
+    if (s->glide_on_mesa && !activate)
+        glide_renderer_stat(1);
+}
+
+void mesa_prepare_window(int msaa, int alpha, int scale_x, void *cwnd_fn)
+{
+    int scr_w, scr_h;
+    struct sdl_console_cb *s = &scon_cb;
+
+    sdl_display_valid("mesapt");
+    s->scon = &sdl2_console[0];
+    s->msaa = msaa;
+    s->alpha = alpha;
+#ifdef CONFIG_WIN32
+    s->GLon12 = s->alpha;
+    s->alpha = 1;
+#endif
+#ifdef CONFIG_DARWIN
+    s->dtimer = s->alpha;
+    s->alpha = 1;
+#endif
+    s->opaque = 0;
+    s->cwnd_fn = (void (*)(void *, void *, void *))cwnd_fn;
+
+    SDL_GetWindowSize(s->scon->real_window, &scr_w, &scr_h);
+    s->gui_saved_res = ((scr_h & 0x7FFFU) << 0x10) | scr_w;
+    s->res = (((int)(scale_x * ((1.f * scr_h) / scr_w)) & 0x7FFFU) << 0x10) | scale_x;
+
+    if (!s->ts)
+        s->ts = timer_new_ms(QEMU_CLOCK_REALTIME, &sched_wndproc, s);
+    timer_mod(s->ts, qemu_clock_get_ms(QEMU_CLOCK_REALTIME));
+}
+
+void mesa_release_window(void)
+{
+    struct sdl_console_cb *s = &scon_cb;
+
+    sdl_display_valid("mesapt");
+    s->scon = &sdl2_console[0];
+    s->res = 0;
+    s->opaque = 0;
+    s->cwnd_fn = 0;
+    s->gui_saved_res = 0;
+
+    if (guest_sprite)
+        SDL_FreeCursor(guest_sprite);
+    guest_sprite = SDL_CreateSystemCursor(0);
+
+    if (s->ts)
+        timer_mod(s->ts, qemu_clock_get_ms(QEMU_CLOCK_REALTIME));
+}
+
+void mesa_cursor_define(int hot_x, int hot_y, int width, int height, const void *data)
+{
+    struct sdl_console_cb *s = &scon_cb;
+
+    QemuConsole *con = s->scon ? s->scon->dcl.con : NULL;
+    if (con) {
+        QEMUCursor *c = cursor_alloc(width, (height & 1)? (height >> 1):height);
+        c->hot_x = hot_x;
+        c->hot_y = hot_y;
+        if (height &  1) {
+            uint8_t *and_mask = (uint8_t *)data,
+                    *xor_mask = and_mask + cursor_get_mono_bpl(c) * c->height;
+            cursor_set_mono(c, 0xffffff, 0x000000, xor_mask, 1, and_mask);
+        }
+        else
+            memcpy(c->data, data, (width * height * sizeof(uint32_t)));
+        dpy_cursor_define(con, c);
+        cursor_unref(c);
+    }
+}
+
+void mesa_mouse_warp(int x, int y, const int on)
+{
+    struct sdl_console_cb *s = &scon_cb;
+
+    QemuConsole *con = s->scon ? s->scon->dcl.con : NULL;
+    if (con /*&& !qemu_input_is_absolute(con)*/) {
+        static int64_t last_update;
+        int64_t curr_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);
+        if (!on || (curr_time >= (last_update + GUI_REFRESH_INTERVAL_DEFAULT))) {
+            last_update = curr_time;
+            dpy_mouse_set(con, x, y, on);
+        }
+    }
+}
+
+int mesa_gui_fullscreen(int *sizev)
+{
+    return sdl_gui_fullscreen(sizev, "mesapt");
+}
+
 static const DisplayChangeListenerOps dcl_2d_ops = {
     .dpy_name             = "sdl2-2d",
     .dpy_gfx_update       = sdl2_2d_update,
@@ -807,7 +1187,7 @@
     .dpy_cursor_define    = sdl_mouse_define,
 };
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 static const DisplayChangeListenerOps dcl_gl_ops = {
     .dpy_name                = "sdl2-gl",
     .dpy_gfx_update          = sdl2_gl_update,
@@ -841,7 +1221,7 @@
 {
     assert(o->type == DISPLAY_TYPE_SDL);
     if (o->has_gl && o->gl) {
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         display_opengl = 1;
 #endif
     }
@@ -911,7 +1291,7 @@
         }
         sdl2_console[i].idx = i;
         sdl2_console[i].opts = o;
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
         sdl2_console[i].opengl = display_opengl;
         sdl2_console[i].dcl.ops = display_opengl ? &dcl_gl_ops : &dcl_2d_ops;
         sdl2_console[i].dgc.ops = display_opengl ? &gl_ctx_ops : NULL;
@@ -952,6 +1332,7 @@
     g_free(dir);
     if (icon) {
         SDL_SetWindowIcon(sdl2_console[0].real_window, icon);
+        scon_cb.icon = icon;
     }
 
     mouse_mode_notifier.notify = sdl_mouse_mode_change;
@@ -980,6 +1361,6 @@
 
 type_init(register_sdl1);
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL) && defined(CONFIG_EGL)
 module_dep("ui-opengl");
 #endif
diff -Nru ../orig/qemu-9.2.0/ui/shader/texture-blit-flip.vert ./ui/shader/texture-blit-flip.vert
--- ../orig/qemu-9.2.0/ui/shader/texture-blit-flip.vert
+++ ./ui/shader/texture-blit-flip.vert
@@ -1,5 +1,3 @@
-#version 300 es
-
 in vec2  in_position;
 out vec2 ex_tex_coord;
 
diff -Nru ../orig/qemu-9.2.0/ui/shader/texture-blit.frag ./ui/shader/texture-blit.frag
--- ../orig/qemu-9.2.0/ui/shader/texture-blit.frag
+++ ./ui/shader/texture-blit.frag
@@ -1,5 +1,3 @@
-#version 300 es
-
 uniform sampler2D image;
 in  mediump vec2 ex_tex_coord;
 out mediump vec4 out_frag_color;
diff -Nru ../orig/qemu-9.2.0/ui/shader/texture-blit.vert ./ui/shader/texture-blit.vert
--- ../orig/qemu-9.2.0/ui/shader/texture-blit.vert
+++ ./ui/shader/texture-blit.vert
@@ -1,5 +1,3 @@
-#version 300 es
-
 in vec2  in_position;
 out vec2 ex_tex_coord;
 
diff -Nru ../orig/qemu-9.2.0/ui/shader.c ./ui/shader.c
--- ../orig/qemu-9.2.0/ui/shader.c
+++ ./ui/shader.c
@@ -152,17 +152,25 @@
 QemuGLShader *qemu_gl_init_shader(void)
 {
     QemuGLShader *gls = g_new0(QemuGLShader, 1);
-
-    gls->texture_blit_prog = qemu_gl_create_compile_link_program
-        (texture_blit_vert_src, texture_blit_frag_src);
-    gls->texture_blit_flip_prog = qemu_gl_create_compile_link_program
-        (texture_blit_flip_vert_src, texture_blit_frag_src);
+    const char *header = epoxy_is_desktop_gl() ? "#version 140\n" : "#version 300 es\n";
+    char vert_src[256];
+    char frag_src[256];
+    
+    strcpy(vert_src, header);
+    strcat(vert_src, texture_blit_vert_src);
+    strcpy(frag_src, header);
+    strcat(frag_src, texture_blit_frag_src);
+    
+    gls->texture_blit_prog = qemu_gl_create_compile_link_program(vert_src, frag_src);
+    
+    strcpy(vert_src + strlen(header), texture_blit_flip_vert_src);
+    gls->texture_blit_flip_prog = qemu_gl_create_compile_link_program(vert_src, frag_src);
+    
     if (!gls->texture_blit_prog || !gls->texture_blit_flip_prog) {
         exit(1);
     }
 
-    gls->texture_blit_vao =
-        qemu_gl_init_texture_blit(gls->texture_blit_prog);
+    gls->texture_blit_vao = qemu_gl_init_texture_blit(gls->texture_blit_prog);
 
     return gls;
 }
diff -Nru ../orig/qemu-9.2.0/ui/spice-display.c ./ui/spice-display.c
--- ../orig/qemu-9.2.0/ui/spice-display.c
+++ ./ui/spice-display.c
@@ -932,20 +932,17 @@
 }
 
 static void qemu_spice_gl_scanout_texture(DisplayChangeListener *dcl,
-                                          uint32_t tex_id,
-                                          bool y_0_top,
-                                          uint32_t backing_width,
-                                          uint32_t backing_height,
+                                          uint32_t backing_id,
+                                          DisplayGLTextureBorrower backing_borrow,
                                           uint32_t x, uint32_t y,
-                                          uint32_t w, uint32_t h,
-                                          void *d3d_tex2d)
+                                          uint32_t w, uint32_t h)
 {
     SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
     EGLint stride = 0, fourcc = 0;
     int fd = -1;
-
-    assert(tex_id);
-    fd = egl_get_fd_for_texture(tex_id, &stride, &fourcc, NULL);
+    DisplayGLTexture tex = backing_borrow(backing_id);
+    assert(tex.id);
+    fd = egl_get_fd_for_texture(tex.id, &stride, &fourcc, NULL);
     if (fd < 0) {
         fprintf(stderr, "%s: failed to get fd for texture\n", __func__);
         return;
@@ -953,8 +950,8 @@
     trace_qemu_spice_gl_scanout_texture(ssd->qxl.id, w, h, fourcc);
 
     /* note: spice server will close the fd */
-    spice_qxl_gl_scanout(&ssd->qxl, fd, backing_width, backing_height,
-                         stride, fourcc, y_0_top);
+    spice_qxl_gl_scanout(&ssd->qxl, fd, tex.width, tex.height,
+                         stride, fourcc, tex.y_0_top);
     qemu_spice_gl_monitor_config(ssd, x, y, w, h);
     ssd->have_surface = false;
     ssd->have_scanout = true;
